{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LingQ CLI Documentation","text":"<p>Welcome to the LingQ CLI documentation! This tool provides command-line utilities for interacting with LingQ's API, making it easy to automate and enhance your language learning workflows.</p>"},{"location":"#what-is-lingq-cli","title":"What is LingQ CLI?","text":"<p>LingQ CLI is a comprehensive command-line tool that allows you to:</p> <ul> <li>\ud83d\udce4 Upload content - Bulk upload lessons with text and audio to your LingQ courses</li> <li>\ud83c\udfa5 YouTube integration - Import entire YouTube playlists with automatic caption extraction</li> <li>\u23f1\ufe0f Generate timestamps - Automatically create timestamps for your audio lessons</li> <li>\ud83d\udce5 Download content - Export lessons, courses, and vocabulary (LingQs)</li> <li>\ud83d\udcdd Markdown documentation - Generate markdown documentation of your courses</li> <li>\ud83d\udcda Yomitan dictionaries - Convert your LingQ vocabulary to Yomitan dictionary format</li> <li>\ud83d\udd27 Manage courses - Sort, reindex, merge, and organize your lessons</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get started in just a few steps:</p> <ol> <li> <p>Install the package <pre><code>pip install lingq\n</code></pre></p> </li> <li> <p>Configure your API key <pre><code>lingq setup yourLingqApiKey\n</code></pre></p> </li> <li> <p>Start using the CLI <pre><code># Upload a YouTube playlist to a course (replace 129129 with your course ID)\nlingq postyt el 129129 \"https://www.youtube.com/@awesomeyoutuber\"\n\n# Bulk upload a book split by chapters\nlingq post el 129139 \"example/texts\" -a \"example/audios\" --pairing-strategy zip\n\n# Generate timestamps for an entire course\nlingq timestamp de 129129\n</code></pre></p> </li> </ol> <p>Finding Course IDs</p> <p>Most commands need a course ID. Find yours with <code>lingq show my &lt;language&gt;</code> or get it from the course URL on the LingQ website.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#content-upload","title":"Content Upload","text":"<ul> <li>Multiple pairing strategies for matching text and audio files (exact, fuzzy, zip, zipsort)</li> <li>Support for various audio and text formats</li> <li>YouTube playlist import with automatic caption handling</li> </ul>"},{"location":"#course-management","title":"Course Management","text":"<ul> <li>Sort lessons with custom sorting functions (Greek words, Roman numerals, versioned numbers)</li> <li>Reindex lesson titles with automatic numbering</li> <li>Merge multiple courses</li> <li>Resplit Japanese text with updated tokenization</li> </ul>"},{"location":"#data-export","title":"Data Export","text":"<ul> <li>Export vocabulary (LingQs) with translations and audio</li> <li>Generate markdown documentation of courses</li> <li>Create Yomitan dictionaries from your vocabulary</li> <li>Download lesson images</li> </ul>"},{"location":"#developer-friendly","title":"Developer-Friendly","text":"<ul> <li>Async-first design for performance</li> <li>Comprehensive type hints</li> <li>Retry logic with exponential backoff</li> <li>Multi-version API support (v1, v2, v3)</li> </ul>"},{"location":"#command-tree","title":"Command Tree","text":"<pre><code>cli - Lingq command line scripts.\n\u251c\u2500\u2500 get - Get commands.\n\u2502   \u251c\u2500\u2500 courses - Get every course from a list of languages.\n\u2502   \u251c\u2500\u2500 lesson - Get a lesson from its id.\n\u2502   \u251c\u2500\u2500 lessons - Get every lesson from a course id.\n\u2502   \u251c\u2500\u2500 images - Get images.\n\u2502   \u2514\u2500\u2500 words - Get words (LingQs).\n\u251c\u2500\u2500 markdown - Generate markdown files for the given language codes.\n\u251c\u2500\u2500 overview - Library overview.\n\u251c\u2500\u2500 patch - Patch commands.\n\u2502   \u251c\u2500\u2500 audios - Patch a course audio.\n\u2502   \u2514\u2500\u2500 texts - Not implemented.\n\u251c\u2500\u2500 post - Upload a lesson.\n\u251c\u2500\u2500 postyt - Post youtube playlist.\n\u251c\u2500\u2500 resplit - Resplit a course (only for japanese).\n\u251c\u2500\u2500 setup - Creates or updates an .env file with your LingQ API key.\n\u251c\u2500\u2500 show - Show commands.\n\u2502   \u2514\u2500\u2500 my - Show a list with my collections in the given language.\n\u251c\u2500\u2500 sort - Sort all lessons from a course.\n\u251c\u2500\u2500 timestamp - Generate timestamps for a course.\n\u2514\u2500\u2500 yomitan - Make a Yomitan dictionary from a dump generated by 'get_words'.\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Detailed setup instructions and API key management</li> <li>Commands Overview - Learn about all available commands</li> <li>Common Workflows - Step-by-step guides for common tasks</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or higher</li> <li>A LingQ account with API access</li> <li>API key from LingQ's API key page</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>LingQ Website</li> <li>LingQ API Key</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>This guide will walk you through installing the LingQ CLI tool and configuring it for use.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or higher</li> <li>pip (Python package manager)</li> <li>A LingQ account</li> <li>LingQ API key</li> </ul>"},{"location":"installation/#installing-the-package","title":"Installing the Package","text":"<p>Install the LingQ CLI using pip:</p> <pre><code>pip install lingq\n</code></pre> <p>This will install the <code>lingq</code> command and all required dependencies.</p>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>If you need additional functionality for scraping, audio transcription, or development tools:</p> <pre><code># Install with all optional dependencies\npip install lingq[etc]\n\n# Install with test dependencies\npip install lingq[test]\n\n# Install with documentation dependencies\npip install lingq[docs]\n\n# Install everything\npip install lingq[all]\n</code></pre>"},{"location":"installation/#getting-your-api-key","title":"Getting Your API Key","text":"<p>Before using the CLI, you'll need a LingQ API key:</p> <ol> <li>Log in to your LingQ account</li> <li>Navigate to https://www.lingq.com/en/accounts/apikey/</li> <li>Copy your API key</li> </ol> <p>Keep Your API Key Secure</p> <p>Your API key provides full access to your LingQ account. Never share it publicly or commit it to version control.</p>"},{"location":"installation/#configuring-the-cli","title":"Configuring the CLI","text":"<p>Once you have your API key, configure the CLI:</p> <pre><code>lingq setup yourLingqApiKey\n</code></pre> <p>This command creates a <code>.env</code> file in your configuration directory with your API key securely stored.</p>"},{"location":"installation/#configuration-file-location","title":"Configuration File Location","text":"<p>The configuration file is stored in a platform-specific location:</p> <ul> <li>macOS: <code>~/Library/Application Support/lingq/.env</code></li> <li>Linux: <code>~/.config/lingq/.env</code></li> <li>Windows: <code>%APPDATA%\\lingq\\.env</code></li> </ul> <p>The <code>.env</code> file contains:</p> <pre><code>LINGQ_API_KEY=yourLingqApiKey\n</code></pre>"},{"location":"installation/#updating-your-api-key","title":"Updating Your API Key","text":"<p>To update your API key, simply run the setup command again with the new key:</p> <pre><code>lingq setup newApiKey\n</code></pre>"},{"location":"installation/#security-best-practices","title":"Security Best Practices","text":"<p>API Key Security</p> <ul> <li>Never share your API key with others</li> <li>Don't commit your API key to version control</li> <li>If you suspect your key has been compromised, regenerate it on the LingQ website</li> <li>The <code>.env</code> file should have restricted permissions (the tool handles this automatically)</li> </ul> <p>Environment Variables</p> <p>You can also set the API key using an environment variable: <pre><code>export LINGQ_API_KEY=yourLingqApiKey\n</code></pre> This is useful for CI/CD environments or temporary testing.</p>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>Verify that the installation was successful:</p> <pre><code># Check the CLI is installed\nlingq --version\n\n# View available commands\nlingq --help\n\n# Test API connection by viewing your collections\nlingq show my en\n</code></pre> <p>If you see your English collections listed (with their course IDs), everything is working correctly!</p> <p>Finding Course IDs</p> <p>The course ID is shown next to each course name when you run <code>lingq show my &lt;language_code&gt;</code>. You can also find it in the LingQ website URL when viewing a course: <code>https://www.lingq.com/en/learn/en/web/course/129129</code> (129129 is the course ID).</p>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to the project or work with the source code:</p> <pre><code># Clone the repository\ngit clone https://github.com/daxida/lingq.git\ncd lingq\n\n# Install in development mode with all dependencies\npip install -e \".[all]\"\n\n# Run tests\npytest\n\n# Format code\nruff format .\n\n# Type check\nmypy src/\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#command-not-found","title":"Command Not Found","text":"<p>If you get a \"command not found\" error after installation:</p> <ol> <li>Ensure pip's script directory is in your PATH</li> <li>Try using <code>python -m cli</code> instead of <code>lingq</code></li> <li>Restart your terminal</li> </ol>"},{"location":"installation/#api-key-not-found","title":"API Key Not Found","text":"<p>If you get an API key error:</p> <ol> <li>Verify you ran <code>lingq setup yourApiKey</code></li> <li>Check that the <code>.env</code> file exists in the config directory</li> <li>Ensure the API key is valid on the LingQ website</li> </ol>"},{"location":"installation/#permission-errors","title":"Permission Errors","text":"<p>If you encounter permission errors during installation:</p> <pre><code># Use a virtual environment (recommended)\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install lingq\n\n# Or install for user only\npip install --user lingq\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Now that you have the CLI installed and configured:</p> <ul> <li>Learn about available commands</li> <li>Follow common workflow tutorials</li> <li>Explore the API reference</li> </ul>"},{"location":"api-reference/lingqhandler/","title":"LingqHandler API Reference","text":""},{"location":"api-reference/lingqhandler/#lingqhandler.LingqHandler","title":"LingqHandler","text":"<p>Abstraction for the requests sent to the LingQ API.</p> A collection is a course in the API lingo, i.e. a group of lessons. <p>For consistency, 'course_id' is prefered over 'collection_id'.</p> <p>Attributes:</p> Name Type Description <code>lang</code> <code>str</code> <p>The language code for the course (e.g., 'ja' for Japanese).</p> <code>config</code> <code>Config</code> <p>Configuration settings for the LingQ API.</p> <code>session</code> <code>RetryClient</code> <p>A retry-enabled HTTP client session.</p> <code>_user_id</code> <code>int | None</code> <p>The user id. Used for some requests.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>class LingqHandler:\n    \"\"\"Abstraction for the requests sent to the LingQ API.\n\n    NOTE: A collection is a course in the API lingo, i.e. a group of lessons.\n          For consistency, 'course_id' is prefered over 'collection_id'.\n\n    Attributes:\n        lang (str): The language code for the course (e.g., 'ja' for Japanese).\n        config (Config): Configuration settings for the LingQ API.\n        session (RetryClient): A retry-enabled HTTP client session.\n        _user_id (int | None): The user id. Used for some requests.\n\n    \"\"\"\n\n    API_URL_V1 = \"https://www.lingq.com/api\"\n    API_URL_V2 = \"https://www.lingq.com/api/v2\"\n    API_URL_V3 = \"https://www.lingq.com/api/v3\"\n\n    def __init__(self, lang: str) -&gt; None:\n        self.lang = lang\n        self.config = Config()\n        retry_client = RetryClient(\n            client_session=ClientSession(),\n            raise_for_status=False,\n            retry_options=ExponentialRetry(attempts=3),\n        )\n        self.session = retry_client\n        self._user_id = None\n\n    async def __aenter__(self):  # noqa: ANN204\n        return self\n\n    async def __aexit__(self, *_):  # noqa: ANN002, ANN204\n        await self.session.close()\n\n    \"\"\"Debug utils\"\"\"\n\n    async def _options(self, url: str) -&gt; Any:\n        async with self.session.options(url, headers=self.config.headers) as response:\n            return await response.json()\n\n    async def response_debug(self, response: ClientResponse) -&gt; None:  # noqa: C901\n        match response.status:\n            case 524:\n                logger.error(\"LingQ's servers are overloaded: cloudflare timeout (&gt; 100 secs).\")\n            case 429:\n                logger.error(\"Rate limited! Slow down and retry in a couple minutes.\")\n            case 409:\n                logger.warning(\"Conflict. Generating timestamps / splitting twice?\")\n                # Do not print the response text for this error\n                return\n            case 405:\n                logger.warning(\"Timestamps are already being generated...\")\n            case 404:\n                # Not found error.\n                pass\n            case 401:\n                # Invalid APIKEY.\n                pass\n            case 400:\n                # Generic error. Happens for multiple reasons.\n                pass\n            case _:\n                logger.error(f\"Unhandled response code error: {response.status}\")\n\n        if response.headers.get(\"Content-Type\") == \"application/json\":\n            response_json = await response.json()\n            if isinstance(response_json, dict):\n                match response_json.get(\"detail\", \"_SENTINEL\"):\n                    case \"_SENTINEL\":\n                        pass\n                    case \"Invalid token.\":\n                        logger.error(\"Invalid API key. Exiting.\")\n                        sys.exit(1)\n                    case _:\n                        logger.error(\"Uncaught detail\")\n            logger.error(f\"[{response.status}] Response JSON:\\n{response_json}\")\n        else:\n            logger.error(f\"Response text: {response.text}\")\n\n    \"\"\"Generic request\"\"\"\n\n    async def _request(\n        self,\n        method: str,\n        endpoint: str,\n        *,\n        version: int = 3,\n        add_language: bool = True,\n        raw: bool = False,\n        retry_on_locked: bool = False,\n        **kwargs,  # noqa: ANN003\n    ) -&gt; Any:\n        api_url = {\n            1: LingqHandler.API_URL_V1,\n            2: LingqHandler.API_URL_V2,\n            3: LingqHandler.API_URL_V3,\n        }[version]\n\n        if add_language:\n            url = f\"{api_url}/{self.lang}/{endpoint}\"\n        else:\n            url = f\"{api_url}/{endpoint}\"\n\n        logger.trace(f\"{method.upper()} {url}\")\n        if params := kwargs.get(\"params\", \"\"):\n            logger.trace(f\"{params=}\")\n\n        if not retry_on_locked:\n            return await self._send_request(method, url, raw=raw, **kwargs)\n        else:\n            assert raw is False, \"Raw must be false when retrying on locked\"\n            return await self._send_request_retry(method, url, raw=False, **kwargs)\n\n    async def _send_request(\n        self,\n        method: str,\n        url: str,\n        *,\n        raw: bool,\n        quiet: bool = False,\n        **kwargs,  # noqa: ANN003\n    ) -&gt; Any:\n        meth = getattr(self.session, method.lower())\n        async with meth(url, headers=self.config.headers, **kwargs) as response:\n            if not 200 &lt;= response.status &lt; 300:\n                if not quiet:\n                    await self.response_debug(response)\n                return response\n            if raw:\n                return response\n            return await response.json()\n\n    async def _send_request_retry(\n        self,\n        method: str,\n        url: str,\n        *,\n        raw: bool,\n        max_retries: int = 4,\n        **kwargs,  # noqa: ANN003\n    ) -&gt; Any:\n        \"\"\"On locked error, retry 'max_retries' times.\n\n        That is, loop until we get a JSON result that does not look like this:\n        * {'isLocked': 'TOKENIZE_TEXT', 'errorType': 'locked'}\n        * {'isLocked': 'GENERATE_TIMESTAMPS', 'errorType': 'locked'}\n        \"\"\"\n        for retry in range(1, max_retries + 1):\n            response = await self._send_request(method, url, raw=raw, quiet=True, **kwargs)\n            # If _send_request:\n            # * failed:    response is a ClientResponse.\n            # * succeeded: response was already converted to a json.\n            if isinstance(response, ClientResponse):\n                response = await response.json()\n            if response.get(\"errorType\", \"\") != \"locked\":\n                return response\n\n            locked_reason = response[\"isLocked\"]\n            if locked_reason not in LOCKED_REASON_CHOICES:\n                logger.warning(f\"Unexpected lock reason: {locked_reason}\")\n            logger.debug(\n                f\"Content is locked at {locked_reason}. Retrying... ({retry}/{max_retries})\"\n            )\n            await asyncio.sleep(2**retry)\n\n        raise RuntimeError(\"Content is locked.\")\n\n    \"\"\"Get requests\"\"\"\n\n    async def get_user_id(self) -&gt; None:\n        \"\"\"Get and cache the user id.\"\"\"\n        if self._user_id is None:\n            data = await self._request(\"GET\", \"profile/\", version=1, add_language=False)\n            self._user_id = data[\"id\"]\n            logger.trace(f\"Cached user id {self._user_id}\")\n\n    async def _get_user_langs(self) -&gt; list[str]:\n        \"\"\"Get a list of language codes with known words.\n\n        https://www.lingq.com/apidocs/api-2.0.html#get\n        \"\"\"\n        data = await self._request(\"GET\", \"languages\", version=2, add_language=False)\n        return [lc[\"code\"] for lc in data if lc[\"knownWords\"] &gt; 0]\n\n    @classmethod\n    def get_user_langs(cls) -&gt; list[str]:\n        \"\"\"Get a list of language codes with known words.\n\n        This is a class method since it does not require initializing a language code.\n        \"\"\"\n\n        async def get_user_langs_tmp() -&gt; list[str]:\n            async with cls(\"Filler\") as handler:\n                return await handler._get_user_langs()\n\n        return asyncio.run(get_user_langs_tmp())\n\n    async def get_lesson_from_id(self, lesson_id: int) -&gt; LessonV3:\n        \"\"\"Get a lesson, from its id.\n\n        Example:\n            id: 34754329\n            url: https://www.lingq.com/api/v3/LANG/lessons/ID/\n\n        \"\"\"\n        data = await self._request(\n            \"GET\",\n            f\"lessons/{lesson_id}/\",\n            retry_on_locked=True,\n        )\n        return LessonV3.model_validate(data)\n\n    async def get_lesson_from_ids(self, ids: list[int]) -&gt; list[LessonV3]:\n        \"\"\"Get a list of lessons, from their ids.\"\"\"\n        return await asyncio.gather(*(self.get_lesson_from_id(id) for id in ids))\n\n    async def get_collection_lessons_from_id(self, course_id: int) -&gt; list[CollectionLessonResult]:\n        \"\"\"Get a list of lessons, from their collection id.\n\n        Example:\n            id: 537808\n            url: https://www.lingq.com/api/v3/ja/collections/537808/lessons\n\n        \"\"\"\n        base_url_size = len(f\"{LingqHandler.API_URL_V3}/{self.lang}/\")\n        url = f\"{LingqHandler.API_URL_V3}/{self.lang}/collections/{course_id}/lessons/\"\n        collection_lessons = []\n        cur_url = url\n\n        while cur_url:\n            endpoint = cur_url[base_url_size:]\n            res_json = await self._request(\"GET\", endpoint)\n            collection_lessons_at_page = CollectionLessons.model_validate(res_json)\n            collection_lessons.extend(collection_lessons_at_page.results)\n            cur_url = collection_lessons_at_page.next\n\n        if collection_lessons.count == 0:\n            editor_url = get_editor_url(self.lang, course_id, \"course\")\n            logger.warning(\n                f\" The collection {course_id} at {editor_url} has no lessons, (delete it?)\"\n            )\n\n        return collection_lessons\n\n    async def get_my_collections(self) -&gt; MyCollections:\n        data = await self._request(\"GET\", \"collections/my\")\n        if isinstance(data, ClientResponse):\n            # Error occurred (e.g., 404 for invalid language)\n            logger.error(f\"Failed to get collections for language '{self.lang}'\")\n            sys.exit(1)\n        return MyCollections.model_validate(data)\n\n    async def counters(self, collection_ids: list[int]) -&gt; dict[str, Counter]:\n        \"\"\"Return summary information about collections.\"\"\"\n        params = {\"collection\": collection_ids}\n        data = await self._request(\"GET\", \"collections/counters/\", params=params)\n        return {\n            collection_id: model_validate_or_exit(\n                Counter, counter, self.lang, collection_id, \"course\"\n            )\n            for collection_id, counter in data.items()\n        }\n\n    async def search(self, params: dict[str, Any]) -&gt; SearchCollections:\n        data = await self._request(\"GET\", \"search\", params=params)\n        return SearchCollections.model_validate(data)\n\n    async def get_my_collections_shared(self) -&gt; list[SearchCollectionResult]:\n        await self.get_user_id()\n        data = await self.search(\n            {\"type\": \"collection\", \"sharedBy\": str(self._user_id), \"sortBy\": \"recentlyOpened\"}\n        )\n        return data.results\n\n    async def get_currently_studying_collections(self) -&gt; list[SearchCollectionResult]:\n        \"\"\"Get collections from the 'Continue Studying shelf'.\n\n        This includes collections imported by other users.\n        \"\"\"\n        data = await self.search(\n            {\"shelf\": \"my_lessons\", \"type\": \"collection\", \"sortBy\": \"recentlyOpened\"}\n        )\n        return data.results\n\n    async def get_collection_from_id(self, course_id: int) -&gt; CollectionV3:\n        \"\"\"Get a CollectionV3 object.\n\n        This only contains an overview of the collection.\n        \"\"\"\n        data = await self._request(\"GET\", f\"collections/{course_id}\")\n        return CollectionV3.model_validate(data)\n\n    async def get_collection_from_id_v2(self, course_id: int) -&gt; Any:\n        \"\"\"Get a raw JSON for a collection (v2 API).\n\n        TODO: make a model for it.\n        \"\"\"\n        return await self._request(\"GET\", f\"collections/{course_id}\", version=2)\n\n    async def get_collection_object_from_id(self, course_id: int) -&gt; Collection | None:\n        \"\"\"Get a custom Collection object from a course_id.\n\n        Used for markdown generation.\n        \"\"\"\n        collection = await self.get_collection_from_id_v2(course_id)\n        if not collection:\n            return None\n        if collection.get(\"detail\", \"\") == \"Not found.\":\n            logger.warning(f\"Ghost course at: {get_editor_url(self.lang, course_id, 'course')}\")\n            return None\n        col = Collection()\n        col.add_data(self.lang, collection)\n        return col\n\n    async def get_audio_from_lesson(self, lesson: LessonV3) -&gt; bytes | None:\n        \"\"\"Get the audio from a lesson. Return None if there is no audio.\n\n        Note: The key with the audio url is 'audio' in V2 and 'audioUrl' in V3.\n        \"\"\"\n        if not lesson.audio_url:\n            return None\n        async with self.session.get(str(lesson.audio_url)) as response:\n            return await response.read()\n\n    async def get_stats(self) -&gt; Any:\n        \"\"\"Get reading stats for the last 7 days.\n\n        Period options can be found at (replace lang if needed):\n        https://www.lingq.com/api/v3/ja/progress/\n        \"\"\"\n        return await self._request(\n            method=\"GET\",\n            endpoint=\"progress/chart_data/?metric=reading&amp;period=last_7d\",\n        )\n\n    \"\"\"Patch requests\"\"\"\n\n    async def patch_audio(self, lesson_id: int, audio: BufferedReader) -&gt; ClientResponse:\n        \"\"\"PATCH. Replace the audio of a lesson.\"\"\"\n        return await self._request(\n            \"PATCH\", f\"lessons/{lesson_id}/\", data={\"audio\": audio}, raw=True\n        )\n\n    async def patch_text(self, lesson_id: int, text_data: str) -&gt; Any:\n        \"\"\"POST. Replace the text of a lesson.\n\n        Note that this is actually a POST request that works like a patch one.\n        \"\"\"\n        return await self._request(\n            \"POST\", f\"lessons/{lesson_id}/resplit/\", data={\"text\": text_data}\n        )\n\n    async def patch_position(self, lesson_id: int, new_position: int) -&gt; Any:\n        \"\"\"PATCH. Replace the position of a lesson in its course.\"\"\"\n        return await self._request(\"PATCH\", f\"lessons/{lesson_id}\", data={\"pos\": new_position})\n\n    async def patch_course(self, lesson_id: int, new_course_id: int) -&gt; Any:\n        \"\"\"PATCH. Move a lesson to another course.\"\"\"\n        return await self._request(\n            \"PATCH\", f\"lessons/{lesson_id}\", data={\"collection\": new_course_id}\n        )\n\n    async def generate_timestamps(self, lesson_id: int) -&gt; Any:\n        \"\"\"POST. Add timestamps to a lesson.\"\"\"\n        return await self._request(\"POST\", f\"lessons/{lesson_id}/genaudio/\")\n\n    async def _create_course(self, data: dict[str, Any]) -&gt; Any:\n        \"\"\"POST. Create a course.\"\"\"\n        return await self._request(\"POST\", \"collections/\", data=data)\n\n    async def create_course(self, title: str, description: str = \"\") -&gt; Any:\n        \"\"\"Create an empty course given its title and (optional) description.\n\n        Returns the response JSON, which contains an entry \"id\" for the course id.\n        This id can be used for further uploading through post methods.\n        \"\"\"\n        return await self._create_course({\"title\": title, \"description\": description})\n\n    async def post_from_multipart(self, data: FormData, *, raw: bool = False) -&gt; Any:\n        return await self._request(\"POST\", \"lessons/import/\", data=data, raw=raw)\n\n    async def post_from_data_dict(self, data: dict[str, Any], *, raw: bool = False) -&gt; Any:\n        \"\"\"POST. Post a lesson from a dictionary.\n\n        F.e.\n            data = {\n                \"title\": \"tmp_title\",\n                \"text\": \"Hello, world!\",\n                \"status\": \"private\",  # default\n                \"level\": 0,           # default\n                \"collection\": course_id,\n                \"save\": True,         # Needed\n            }\n        \"\"\"\n        self._check_data_conv(data)\n        fdata = FormData(data)\n        return await self.post_from_multipart(fdata, raw=raw)\n\n    def _check_data_conv(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"Verify that we have the keys needed by LingQ.\"\"\"\n        needed_keys = {\"title\", \"collection\", \"save\"}\n        need_one_of = {\"text\", \"url\"}\n        keys = set(data.keys())\n        if not keys &amp; need_one_of:\n            raise ValueError(f\"Data needs at least one entry in {need_one_of}\")\n        for key in needed_keys:\n            if key not in data:\n                raise ValueError(f\"Error at post_from_data_dict: data has no {key=}\")\n\n    async def replace(self, lesson_id: int, replacements: dict[str, str]) -&gt; ClientResponse:\n        \"\"\"POST. Regex-like replace text in a lesson.\n\n        A replacement is a pair {regex: substition}. F.e. {\"a\": \"b\", \"c\": \"d\"}\n        I'm aware that the first argument is a regex because of the error messages\n        with the '[]' characters, but I haven't actually used it with a regex.\n\n        This does not use _post because it requires the data to be sent as json.\n        \"\"\"\n        return await self._request(\n            \"POST\",\n            f\"lessons/{lesson_id}/sentences/\",\n            json={\"action\": \"replace\", \"text\": replacements},\n            raw=True,\n        )\n\n    async def replace_sentence(self, lesson_id: int, text: str, index: int) -&gt; ClientResponse:\n        \"\"\"POST. Replace a sentence in a lesson.\"\"\"\n        return await self._request(\n            \"POST\",\n            f\"lessons/{lesson_id}/sentences/\",\n            json={\"action\": \"update\", \"index\": index, \"text\": text},\n            raw=True,\n        )\n\n    async def _has_title_paragraph(self, lesson_id: int) -&gt; bool:\n        \"\"\"This is awful and I am convinced it is exactly what LingQ does internally.\"\"\"\n        paragraphs = await self._request(\"GET\", f\"lessons/{lesson_id}/paragraphs/\")\n        has_title = paragraphs and (paragraphs[0].get(\"style\", \"\") == \"h1\")\n        if not has_title:\n            # Issue a warning since you probably always want a title paragraph\n            editor_url = get_editor_url(self.lang, lesson_id, \"lesson\")\n            logger.warning(f\"Missing title paragraph at lesson @ {editor_url}\")\n        return has_title\n\n    async def replace_title(self, lesson_id: int, text: str) -&gt; ClientResponse:\n        \"\"\"POST/PATCH. Replace the title of a lesson.\"\"\"\n        has_title = await self._has_title_paragraph(lesson_id)\n        if has_title:\n            # Works if the first line is TITLE\n            return await self.replace_sentence(lesson_id, text, index=1)\n        else:\n            # Works if the first line is PARAGRAPH 1 (~~no title, f.e. youtube import)\n            # Does not modify the first sentence, but then again, there is no guarantee that\n            # we _want_ to modify the first sentence, since it may not be the title...\n            return await self._request(\"PATCH\", f\"lessons/{lesson_id}\", data={\"title\": text})\n\n    async def resplit_lesson(self, lesson_id: int, method: str) -&gt; ClientResponse:\n        \"\"\"Resplit a Japanese lesson using the new splitting logic.\n\n        https://forum.lingq.com/t/refining-parsing-in-spaceless-languages-like-japanese-with-ai/179754/5\n        \"\"\"\n        if method != \"ichimoe\":\n            msg = \"Only method=ichimoe is supported.\"\n            raise NotImplementedError(msg)\n        return await self._request(\n            \"POST\",\n            f\"lessons/{lesson_id}/resplit/\",\n            data={\"method\": method},\n            raw=True,\n        )\n\n    async def delete_course(self, course_id: int) -&gt; None:\n        \"\"\"Delete a course.\n\n        Crashes if the course is not succesfully deleted.\n        \"\"\"\n        url = f\"{LingqHandler.API_URL_V3}/{self.lang}/collections/{course_id}\"\n        async with self.session.delete(url, headers=self.config.headers) as response:\n            if response.status != 202:\n                msg = \"The course could not be successfully deleted\"\n                raise RuntimeError(msg)\n</code></pre>"},{"location":"api-reference/lingqhandler/#lingqhandler.LingqHandler.__init__","title":"__init__","text":"<pre><code>__init__(lang: str) -&gt; None\n</code></pre> Source code in <code>src/lingqhandler.py</code> <pre><code>def __init__(self, lang: str) -&gt; None:\n    self.lang = lang\n    self.config = Config()\n    retry_client = RetryClient(\n        client_session=ClientSession(),\n        raise_for_status=False,\n        retry_options=ExponentialRetry(attempts=3),\n    )\n    self.session = retry_client\n    self._user_id = None\n</code></pre>"},{"location":"api-reference/lingqhandler/#lingqhandler.LingqHandler.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> Source code in <code>src/lingqhandler.py</code> <pre><code>async def __aenter__(self):  # noqa: ANN204\n    return self\n</code></pre>"},{"location":"api-reference/lingqhandler/#lingqhandler.LingqHandler.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(*_)\n</code></pre> Source code in <code>src/lingqhandler.py</code> <pre><code>async def __aexit__(self, *_):  # noqa: ANN002, ANN204\n    await self.session.close()\n</code></pre>"},{"location":"api-reference/lingqhandler/#lingqhandler.LingqHandler.get_my_collections","title":"get_my_collections  <code>async</code>","text":"<pre><code>get_my_collections() -&gt; MyCollections\n</code></pre> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_my_collections(self) -&gt; MyCollections:\n    data = await self._request(\"GET\", \"collections/my\")\n    if isinstance(data, ClientResponse):\n        # Error occurred (e.g., 404 for invalid language)\n        logger.error(f\"Failed to get collections for language '{self.lang}'\")\n        sys.exit(1)\n    return MyCollections.model_validate(data)\n</code></pre>"},{"location":"api-reference/models/","title":"Models API Reference","text":"<p>This page documents the Pydantic models used to represent LingQ data structures.</p>"},{"location":"api-reference/models/#lesson-models","title":"Lesson Models","text":""},{"location":"api-reference/models/#lessonv3","title":"LessonV3","text":""},{"location":"api-reference/models/#models.lesson_v3.LessonV3","title":"LessonV3","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/models/lesson_v3.py</code> <pre><code>class LessonV3(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=to_camel,\n        populate_by_name=True,\n    )\n\n    id: int\n    content_id: int\n    collection_id: int\n    collection_title: str\n    url: HttpUrl\n    original_url: HttpUrl | Literal[\"\"] | None\n    image_url: HttpUrl\n    original_image_url: HttpUrl\n    provider_image_url: HttpUrl | None\n    title: str\n    description: str\n    duration: int\n    audio_url: HttpUrl | None\n    audio_pending: bool\n    give_rose_url: str\n    word_count: int\n    unique_word_count: int\n    pub_date: str\n    shared_date: str | None\n    shared_by_id: int\n    shared_by_name: str\n    shared_by_role: str | None\n    external_type: str | None\n    type: str\n    # P := shared, D := private, R := rejected, X := None\n    status: Literal[\"P\", \"D\", \"R\", \"X\"]\n    pos: int\n    price: int\n    opened: bool\n    completed: bool\n    percent_completed: float\n    new_words_count: int\n    difficulty: float\n    provider_name: str | None\n    provider_description: str | None\n    last_rose_received: str | None\n    lesson_rating: int\n    lesson_votes: int\n    audio_rating: int\n    audio_votes: int\n    roses_count: int\n    is_favorite: bool\n    is_over_limit: bool | None\n    level: str | None\n    tags: list[str]\n    # Sometimes it is just an empty string...\n    provider_url: str | None\n    read_times: float\n    listen_times: float\n    rose_given: bool\n    open_date: str | None\n    views_count: int\n    is_protected: int | None\n    scheduled_for_deletion: bool\n    metadata: Metadata | None\n    classic_url: str | None\n    collection: CollectionV3\n    folders: list[int]\n    is_legacy: bool\n    simplified_to: str | None\n    simplified_by: str | None\n    tokenized_text: list[list[TokenGroup]]\n    is_locked: bool | LockedReason | None\n    shared_by_image_url: HttpUrl\n    shared_by_is_friend: bool\n    print_url: str | None\n    can_edit: bool\n    can_edit_sentence: bool\n    bookmark: dict[str, Any]\n    next_lesson_id: int | None = None\n    previous_lesson_id: int | None = None\n    previous_lesson: PreviousLesson | None = None\n    next_lesson: PreviousLesson | None = None\n    translation: LessonTranslation | None\n    video_url: str | None\n    cards: dict[str, Any]\n    cards_count: int\n    words: dict[str, Word]\n\n    # Custom attributes\n    _downloaded_audio: bytes | None = None\n    _timestamps: str | None = None\n\n    def get_raw_text(self) -&gt; str:\n        # The first element is the lesson title, that we don't use.\n        # Note that some defective lessons may not have a title,\n        # and makes us skip the first paragraph.\n        return \"\\n\".join(\" \".join(t.text for t in tokens) for tokens in self.tokenized_text[1:])\n\n    def to_vtt(self) -&gt; str | None:\n        vtt_lines = [\"WEBVTT\\n\"]\n\n        idx_token = 0\n        # The first element is the lesson title, that we don't use.\n        # Note that some defective lessons may not have a title,\n        # and makes us skip the first paragraph.\n        for paragraph_data in self.tokenized_text[1:]:\n            for token_group in paragraph_data:\n                start_time, end_time = token_group.timestamp\n                if start_time is None or end_time is None:\n                    # Early exit: the text has no timestamps\n                    logger.warning(f\"Lesson {self.title} has no subtitles\")\n                    return None\n                start = format_timestamp(start_time)\n                end = format_timestamp(end_time)\n\n                idx_token += 1\n                vtt_lines.append(f\"{idx_token}\")\n                vtt_lines.append(f\"{start} --&gt; {end}\")\n                vtt_lines.append(token_group.text)\n                vtt_lines.append(\"\")\n\n        return \"\\n\".join(vtt_lines)\n</code></pre>"},{"location":"api-reference/models/#collection-models","title":"Collection Models","text":""},{"location":"api-reference/models/#collectionv3","title":"CollectionV3","text":""},{"location":"api-reference/models/#models.collection_v3.CollectionV3","title":"CollectionV3","text":"<p>               Bases: <code>BaseModel</code></p> <p>Collection model for API v3.</p> <p>https://www.lingq.com/api/v3/el/collections/1765504/</p> Source code in <code>src/models/collection_v3.py</code> <pre><code>class CollectionV3(BaseModel):\n    \"\"\"Collection model for API v3.\n\n    https://www.lingq.com/api/v3/el/collections/1765504/\n    \"\"\"\n\n    model_config = ConfigDict(\n        alias_generator=to_camel,\n        populate_by_name=True,\n    )\n\n    id: int\n    type: str\n    title: str\n    status: str\n    source: CollectionSource | None\n    is_taken: bool | None\n    image_url: HttpUrl\n    audio_pending: bool\n    original_image_url: HttpUrl | None\n    provider_image_url: HttpUrl | None\n    shared_by_image_url: HttpUrl\n    provider_id: int | None\n    provider_name: str | None\n    shared_by_id: int\n    shared_by_name: str\n    shared_by_role: str | None\n    description: str\n    is_featured: bool | None\n    is_locked: bool | None\n    lessons_count: int\n    new_words_count: int\n    difficulty: float\n    roses_count: int\n    views_count: int\n    duration: int\n    progress: str | None\n    # metadata: dict | None\n    folders: list[int]\n    accent: str | None\n    level: str | None\n    price: int\n    date: str\n    tags: list[str]\n    url: str\n</code></pre>"},{"location":"api-reference/models/#collection","title":"Collection","text":""},{"location":"api-reference/models/#models.collection.Collection","title":"Collection  <code>dataclass</code>","text":"<p>This collection object uses LingQ's API V2.</p> Source code in <code>src/models/collection.py</code> <pre><code>@dataclass\nclass Collection:\n    \"\"\"This collection object uses LingQ's API V2.\"\"\"\n\n    # fmt: off\n    _id:            int = 0\n    title:          str | None = None\n    lang:           str | None = None\n    course_url:     str | None = None\n    level:          str = \"-\"\n    has_audio:      bool = False\n    is_shared:      bool = False\n    first_update:   str | None = None\n    last_update:    str | None = None\n    amount_lessons: int = 0\n    views_count:    int = 0\n    # fmt: on\n\n    def add_data(self, lang: str, collection_v2: Any) -&gt; None:\n        \"\"\"Transfer the data from the JSON to the Collection object.\n        Can't use V3 because of the lack of pubDate...\n        \"\"\"\n        self.lang = lang\n        self._id = collection_v2[\"pk\"]  # it's pk in V2 and id in V3\n        self.title = collection_v2[\"title\"]\n        editor_url = get_editor_url(lang, int(self._id), \"course\")\n        self.course_url = editor_url\n\n        lessons = collection_v2[\"lessons\"]\n        if not lessons:\n            logger.warning(f\"No lessons found for '{self.title}' at {editor_url}\")\n            return\n\n        self.level = TO_EUROPEAN.get(collection_v2[\"level\"], collection_v2[\"level\"]) or \"-\"\n        self.has_audio = lessons[0][\"audio\"] is not None\n        self.last_update = lessons[0][\"pubDate\"]\n        self.first_update = lessons[0][\"pubDate\"]\n\n        for lesson in lessons:\n            # The collection has audio if at least one lesson has audio:\n            self.has_audio = self.has_audio or (lesson[\"audio\"] is not None)\n\n            # The collection is shated if at least one lesson is shared:\n            # NOTE: D for private, P for public\n            self.is_shared = self.is_shared or (lesson[\"status\"] == \"P\")\n            # print(lesson[\"status\"] == \"P\")\n\n            # Track the first and last updates:\n            assert self.first_update is not None\n            assert self.last_update is not None\n            cur_update = dt.strptime(lesson[\"pubDate\"], \"%Y-%m-%d\")\n            if dt.strptime(self.first_update, \"%Y-%m-%d\") &gt; cur_update:\n                self.first_update = lesson[\"pubDate\"]\n            if dt.strptime(self.last_update, \"%Y-%m-%d\") &lt; cur_update:\n                self.last_update = lesson[\"pubDate\"]\n\n            # The view count is the total sum of the viewsCount of the lessons\n            self.views_count += lesson[\"viewsCount\"]\n\n        # We remove our own view from the count (assuming we read everything).\n        self.amount_lessons = len(lessons)\n        self.views_count -= self.amount_lessons\n</code></pre>"},{"location":"api-reference/models/#models.collection.Collection.add_data","title":"add_data","text":"<pre><code>add_data(lang: str, collection_v2: Any) -&gt; None\n</code></pre> <p>Transfer the data from the JSON to the Collection object. Can't use V3 because of the lack of pubDate...</p> Source code in <code>src/models/collection.py</code> <pre><code>def add_data(self, lang: str, collection_v2: Any) -&gt; None:\n    \"\"\"Transfer the data from the JSON to the Collection object.\n    Can't use V3 because of the lack of pubDate...\n    \"\"\"\n    self.lang = lang\n    self._id = collection_v2[\"pk\"]  # it's pk in V2 and id in V3\n    self.title = collection_v2[\"title\"]\n    editor_url = get_editor_url(lang, int(self._id), \"course\")\n    self.course_url = editor_url\n\n    lessons = collection_v2[\"lessons\"]\n    if not lessons:\n        logger.warning(f\"No lessons found for '{self.title}' at {editor_url}\")\n        return\n\n    self.level = TO_EUROPEAN.get(collection_v2[\"level\"], collection_v2[\"level\"]) or \"-\"\n    self.has_audio = lessons[0][\"audio\"] is not None\n    self.last_update = lessons[0][\"pubDate\"]\n    self.first_update = lessons[0][\"pubDate\"]\n\n    for lesson in lessons:\n        # The collection has audio if at least one lesson has audio:\n        self.has_audio = self.has_audio or (lesson[\"audio\"] is not None)\n\n        # The collection is shated if at least one lesson is shared:\n        # NOTE: D for private, P for public\n        self.is_shared = self.is_shared or (lesson[\"status\"] == \"P\")\n        # print(lesson[\"status\"] == \"P\")\n\n        # Track the first and last updates:\n        assert self.first_update is not None\n        assert self.last_update is not None\n        cur_update = dt.strptime(lesson[\"pubDate\"], \"%Y-%m-%d\")\n        if dt.strptime(self.first_update, \"%Y-%m-%d\") &gt; cur_update:\n            self.first_update = lesson[\"pubDate\"]\n        if dt.strptime(self.last_update, \"%Y-%m-%d\") &lt; cur_update:\n            self.last_update = lesson[\"pubDate\"]\n\n        # The view count is the total sum of the viewsCount of the lessons\n        self.views_count += lesson[\"viewsCount\"]\n\n    # We remove our own view from the count (assuming we read everything).\n    self.amount_lessons = len(lessons)\n    self.views_count -= self.amount_lessons\n</code></pre>"},{"location":"api-reference/models/#vocabulary-models","title":"Vocabulary Models","text":""},{"location":"api-reference/models/#card","title":"Card","text":""},{"location":"api-reference/models/#models.cards.Card","title":"Card","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/models/cards.py</code> <pre><code>class Card(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=to_camel,\n        populate_by_name=True,\n    )\n\n    pk: int\n    # Unused\n    # url: str\n    term: str\n    fragment: str\n    importance: int\n    # LingQ status (0-4?)\n    status: int\n    # Unused\n    # extended_status: Optional[int] = None\n    # last_reviewed_correct: Optional[str] = None\n    # srs_due_date: str\n    notes: str\n    audio: str | None = None\n    words: list[str]\n    tags: list[str]\n    hints: list[Hint]\n    transliteration: Transliteration = Transliteration()\n    g_tags: list[str]\n    word_tags: list[str]\n    readings: Readings = Readings()\n    writings: list[str]\n</code></pre>"},{"location":"api-reference/models/#hint","title":"Hint","text":""},{"location":"api-reference/models/#models.hint.Hint","title":"Hint","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/models/hint.py</code> <pre><code>class Hint(BaseModel):\n    id: int\n    locale: str\n    text: str\n    term: str | None = None\n    popularity: int\n    is_google_translate: bool\n    flagged: bool\n</code></pre>"},{"location":"api-reference/models/#other-models","title":"Other Models","text":""},{"location":"api-reference/models/#counter","title":"Counter","text":""},{"location":"api-reference/models/#models.counter.Counter","title":"Counter","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/models/counter.py</code> <pre><code>class Counter(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=to_camel,\n        populate_by_name=True,\n    )\n\n    cards_count: int\n    has_flags: bool\n    known_words_count: int\n    total_words_count: int\n    rose_given: bool\n    roses_count: int\n    lessons_count: int\n    difficulty: float\n    is_taken: bool\n    new_words_count: int\n    pk: int\n    progress: float | None = None\n    listen_times: float | None = None\n    is_completely_taken: bool\n    unique_words_count: int\n    read_times: float | None = None\n</code></pre>"},{"location":"api-reference/models/#transliteration","title":"Transliteration","text":""},{"location":"api-reference/models/#models.transliteration.Transliteration","title":"Transliteration","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/models/transliteration.py</code> <pre><code>class Transliteration(BaseModel):\n    # This:\n    # - Has no keys for german or english\n    # - Has exactly one key for greek: \"transliteration\": {\"latin\": [\"paraschete\"]}\n    # - Has exactly three keys for japanese: \"hiragana\", \"furigana\" and \"romaji\".\n    readings: dict[str, list[Any]] = {}\n</code></pre>"},{"location":"api-reference/models/#readings","title":"Readings","text":""},{"location":"api-reference/models/#models.readings.Readings","title":"Readings","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/models/readings.py</code> <pre><code>class Readings(BaseModel):\n    readings: dict[str, list[str]] = {}\n</code></pre>"},{"location":"api-reference/utils/","title":"Utilities API Reference","text":"<p>This page documents utility functions available in the LingQ CLI.</p>"},{"location":"api-reference/utils/#utils","title":"utils","text":""},{"location":"api-reference/utils/#utils.get_editor_url","title":"get_editor_url","text":"<pre><code>get_editor_url(lang: str, content_id: int, content_type: ContentType) -&gt; str\n</code></pre> Source code in <code>src/utils.py</code> <pre><code>def get_editor_url(lang: str, content_id: int, content_type: ContentType) -&gt; str:\n    base = f\"https://www.lingq.com/learn/{lang}/web/editor\"\n    if content_type == \"course\":\n        base = f\"{base}/courses\"\n    return f\"{base}/{content_id}\"\n</code></pre>"},{"location":"api-reference/generated/cli/","title":"cli","text":""},{"location":"api-reference/generated/cli/#cli","title":"cli","text":""},{"location":"api-reference/generated/cli/#cli.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=Callable[..., Any])\n</code></pre> <p>Simple version of click.decorators.FC.</p>"},{"location":"api-reference/generated/cli/#cli.cli","title":"cli","text":"<pre><code>cli() -&gt; None\n</code></pre> <p>Lingq command line scripts.</p> <p>You can always get more details about a command with the --help flag.</p> Source code in <code>src/cli.py</code> <pre><code>@click.group()\n@click.version_option(package_name=\"lingq\")\ndef cli() -&gt; None:\n    \"\"\"Lingq command line scripts.\n\n    You can always get more details about a command with the --help flag.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.setup_cli","title":"setup_cli","text":"<pre><code>setup_cli(apikey: str) -&gt; None\n</code></pre> <p>Creates or updates an config file with your LingQ API key.</p> <p>You can find your API key at: https://www.lingq.com/accounts/apikey/</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"setup\")\n@click.argument(\"apikey\")\ndef setup_cli(apikey: str) -&gt; None:\n    \"\"\"Creates or updates an config file with your LingQ API key.\n\n    You can find your API key at: https://www.lingq.com/accounts/apikey/\n    \"\"\"\n\n    if CONFIG_PATH.exists():\n        with CONFIG_PATH.open(\"r\") as file:\n            lines = file.readlines()\n\n        # Update the API_KEY if it exists, otherwise add a new line\n        with CONFIG_PATH.open(\"w\") as file:\n            api_key_found = False\n            for line in lines:\n                if line.startswith(\"APIKEY=\"):\n                    file.write(f\"APIKEY={apikey}\\n\")\n                    api_key_found = True\n                else:\n                    file.write(line)\n\n            if not api_key_found:\n                file.write(f\"APIKEY={apikey}\\n\")\n\n        print(f\"Config file has been updated at {CONFIG_PATH}\")\n    else:\n        CONFIG_DIR.mkdir(parents=True, exist_ok=True)\n        with CONFIG_PATH.open(\"w\") as file:\n            file.write(f\"APIKEY={apikey}\\n\")\n\n        print(f\"Config file has been created at {CONFIG_PATH}\")\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show commands.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.group()\ndef show() -&gt; None:\n    \"\"\"Show commands.\"\"\"\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.show_my_cli","title":"show_my_cli","text":"<pre><code>show_my_cli(lang: str, shared: bool, codes: bool, verbose: bool) -&gt; None\n</code></pre> <p>Show my collections in a given language.</p> Source code in <code>src/cli.py</code> <pre><code>@show.command(\"my\")\n@click.argument(\"lang\")\n@click.option(\"-s\", \"--shared\", is_flag=True, default=False, show_default=True)\n@click.option(\"-c\", \"--codes\", is_flag=True, default=False, show_default=True)\n@click.option(\"-v\", \"--verbose\", is_flag=True, default=False, show_default=True)\ndef show_my_cli(lang: str, shared: bool, codes: bool, verbose: bool) -&gt; None:\n    \"\"\"Show my collections in a given language.\"\"\"\n    show_my(lang, shared=shared, codes=codes, verbose=verbose)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.show_course_cli","title":"show_course_cli","text":"<pre><code>show_course_cli(lang: str, course_id: int, shared: bool, codes: bool, verbose: bool) -&gt; None\n</code></pre> <p>Show lessons in a course.</p> Source code in <code>src/cli.py</code> <pre><code>@show.command(\"course\")\n@click.argument(\"lang\")\n@click.argument(\"course_id\")\n@click.option(\"-s\", \"--shared\", is_flag=True, default=False, show_default=True)\n@click.option(\"-c\", \"--codes\", is_flag=True, default=False, show_default=True)\n@click.option(\"-v\", \"--verbose\", is_flag=True, default=False, show_default=True)\ndef show_course_cli(\n    lang: str,\n    course_id: int,\n    shared: bool,\n    codes: bool,\n    verbose: bool,\n) -&gt; None:\n    \"\"\"Show lessons in a course.\"\"\"\n    show_course(lang, course_id, shared=shared, codes=codes, verbose=verbose)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.show_status_cli","title":"show_status_cli","text":"<pre><code>show_status_cli(lang: str) -&gt; None\n</code></pre> <p>Show pending and refused lessons in a language.</p> Source code in <code>src/cli.py</code> <pre><code>@show.command(\"status\")\n@click.argument(\"lang\")\ndef show_status_cli(lang: str) -&gt; None:\n    \"\"\"Show pending and refused lessons in a language.\"\"\"\n    show_status(lang)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.get","title":"get","text":"<pre><code>get() -&gt; None\n</code></pre> <p>Get commands.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.group()\ndef get() -&gt; None:\n    \"\"\"Get commands.\"\"\"\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.get_images_cli","title":"get_images_cli","text":"<pre><code>get_images_cli(lang: str, course_id: int, opath: Path) -&gt; None\n</code></pre> <p>Get images.</p> Source code in <code>src/cli.py</code> <pre><code>@get.command(\"images\")\n@click.argument(\"lang\")\n@click.argument(\"course_id\")\n@opath_option()\ndef get_images_cli(lang: str, course_id: int, opath: Path) -&gt; None:\n    \"\"\"Get images.\"\"\"\n    get_images(lang, course_id, opath)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.get_words_cli","title":"get_words_cli","text":"<pre><code>get_words_cli(langs: list[str], opath: Path) -&gt; None\n</code></pre> <p>Get words (LingQs).</p> Source code in <code>src/cli.py</code> <pre><code>@get.command(\"words\")\n@click.argument(\"langs\", nargs=-1)\n@opath_option()\ndef get_words_cli(langs: list[str], opath: Path) -&gt; None:\n    \"\"\"Get words (LingQs).\"\"\"\n    get_words(langs, opath)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.yomitan_cli","title":"yomitan_cli","text":"<pre><code>yomitan_cli(langs: list[str], ipath: Path) -&gt; None\n</code></pre> <p>Make a Yomitan dictionary from a dump generated by 'get_words'.</p> <p>If no language codes are given, use all languages.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"yomitan\")\n@click.argument(\"langs\", nargs=-1)\n@click.option(\n    \"--ipath\",\n    \"-i\",\n    default=DEFAULT_OUT_WORDS_PATH,\n    show_default=True,\n    type=click.Path(exists=True, path_type=Path),\n    help=\"Input path.\",\n)\ndef yomitan_cli(langs: list[str], ipath: Path) -&gt; None:\n    \"\"\"Make a Yomitan dictionary from a dump generated by 'get_words'.\n\n    If no language codes are given, use all languages.\n    \"\"\"\n    yomitan(langs, ipath)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.get_lesson_cli","title":"get_lesson_cli","text":"<pre><code>get_lesson_cli(lang: str, lesson_id: int, opath: Path, download_audio: bool, download_timestamps: bool) -&gt; None\n</code></pre> <p>Get a lesson from its id.</p> <p>CAREFUL: This reorders your 'Continue studying' shelf.</p> Source code in <code>src/cli.py</code> <pre><code>@get.command(\"lesson\")\n@click.argument(\"lang\")\n@click.argument(\"lesson_id\")\n@opath_option()\n@click.option(\"--download-audio\", is_flag=True, default=False, help=\"If set, also download audio.\")\n@click.option(\n    \"--download-timestamps\", is_flag=True, default=False, help=\"If set, also download timestamps.\"\n)\ndef get_lesson_cli(\n    lang: str,\n    lesson_id: int,\n    opath: Path,\n    download_audio: bool,\n    download_timestamps: bool,\n) -&gt; None:\n    \"\"\"Get a lesson from its id.\n\n    CAREFUL: This reorders your 'Continue studying' shelf.\n    \"\"\"\n    get_lesson(\n        lang,\n        lesson_id,\n        opath,\n        download_audio=download_audio,\n        download_timestamps=download_timestamps,\n    )\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.get_lessons_cli","title":"get_lessons_cli","text":"<pre><code>get_lessons_cli(lang: str, course_id: int, opath: Path, skip_downloaded: bool, download_audio: bool, download_timestamps: bool, with_index: bool) -&gt; None\n</code></pre> <p>Get every lesson from a course id.</p> <p>CAREFUL: This reorders your 'Continue studying' shelf.</p> Source code in <code>src/cli.py</code> <pre><code>@get.command(\"lessons\")\n@click.argument(\"lang\")\n@click.argument(\"course_id\")\n@opath_option()\n@click.option(\n    \"--skip-downloaded\",\n    \"-s\",\n    is_flag=True,\n    default=False,\n    show_default=True,\n    help=\"Skip already downloaded lessons.\",\n)\n@click.option(\"--download-audio\", is_flag=True, default=False, help=\"If set, also download audio.\")\n@click.option(\n    \"--download-timestamps\", is_flag=True, default=False, help=\"If set, also download timestamps.\"\n)\n@click.option(\"--with-index\", is_flag=True, default=False, help=\"If set, add index to the title.\")\ndef get_lessons_cli(\n    lang: str,\n    course_id: int,\n    opath: Path,\n    skip_downloaded: bool,\n    download_audio: bool,\n    download_timestamps: bool,\n    with_index: bool,\n) -&gt; None:\n    \"\"\"Get every lesson from a course id.\n\n    CAREFUL: This reorders your 'Continue studying' shelf.\n    \"\"\"\n    get_lessons(\n        lang,\n        course_id,\n        opath,\n        skip_downloaded=skip_downloaded,\n        download_audio=download_audio,\n        download_timestamps=download_timestamps,\n        write=True,\n        with_index=with_index,\n    )\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.get_courses_cli","title":"get_courses_cli","text":"<pre><code>get_courses_cli(langs: list[str], opath: Path, download_audio: bool, download_timestamps: bool, skip_downloaded: int, batch_size: int) -&gt; None\n</code></pre> <p>Get every course from a list of languages.</p> <p>CAREFUL: This reorders your 'Continue studying' shelf.</p> <p>If no language codes are given, use all languages.</p> Source code in <code>src/cli.py</code> <pre><code>@get.command(\"courses\")\n@click.argument(\"langs\", nargs=-1)\n@click.option(\"--download-audio\", is_flag=True, default=False, help=\"If set, also download audio.\")\n@click.option(\n    \"--download-timestamps\", is_flag=True, default=False, help=\"If set, also download timestamps.\"\n)\n@click.option(\n    \"--skip-downloaded\",\n    \"-s\",\n    is_flag=True,\n    default=False,\n    show_default=True,\n    help=\"Skip already downloaded lessons.\",\n)\n@click.option(\n    \"--batch-size\",\n    \"-b\",\n    type=int,\n    default=1,\n    show_default=True,\n    help=\"Number of courses to download simultanously. \"\n    \"Increasing this too much may incur in throttling. Suggested: 1 or 2.\",\n)\n@opath_option()\ndef get_courses_cli(\n    langs: list[str],\n    opath: Path,\n    download_audio: bool,\n    download_timestamps: bool,\n    skip_downloaded: int,\n    batch_size: int,\n) -&gt; None:\n    \"\"\"Get every course from a list of languages.\n\n    CAREFUL: This reorders your 'Continue studying' shelf.\n\n    If no language codes are given, use all languages.\n    \"\"\"\n    get_courses(\n        langs,\n        opath,\n        download_audio=download_audio,\n        download_timestamps=download_timestamps,\n        skip_downloaded=skip_downloaded,\n        batch_size=batch_size,\n    )\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.post_cli","title":"post_cli","text":"<pre><code>post_cli(lang: str, course_id: int, texts_folder: Path | None, audios_folder: Path | None, pairing_strategy: str) -&gt; None\n</code></pre> <p>Upload lessons.</p> <p>When no texts are given, LingQ will use whisper to transcribe.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"post\")\n@click.argument(\"lang\")\n@click.argument(\"course_id\")\n@click.option(\n    \"--texts-folder\",\n    \"-t\",\n    default=DEFAULT_TEXTS_FOLDER,\n    type=click.Path(exists=True, path_type=Path),\n    help=\"Texts folder path.\",\n)\n@click.option(\n    \"--audios-folder\",\n    \"-a\",\n    default=DEFAULT_AUDIOS_FOLDER,\n    type=click.Path(exists=True, path_type=Path),\n    help=\"Audios folder path.\",\n)\n@click.option(\n    \"--pairing-strategy\",\n    type=click.Choice(PAIRING_STRATEGIES),\n    default=\"fuzzy\",\n    show_default=True,\n)\ndef post_cli(\n    lang: str,\n    course_id: int,\n    texts_folder: Path | None,\n    audios_folder: Path | None,\n    pairing_strategy: str,\n) -&gt; None:\n    \"\"\"Upload lessons.\n\n    When no texts are given, LingQ will use whisper to transcribe.\n    \"\"\"\n    post(\n        lang,\n        course_id,\n        texts_folder,\n        audios_folder,\n        pairing_strategy,\n    )\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.post_yt_playlist_cli","title":"post_yt_playlist_cli","text":"<pre><code>post_yt_playlist_cli(lang: str, course_id: int, playlist_url: str, skip_uploaded: bool) -&gt; None\n</code></pre> <p>Post a youtube playlist.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"postyt\")\n@click.argument(\"lang\")\n@click.argument(\"course_id\")\n@click.argument(\"playlist_url\")\n@click.option(\"--skip-uploaded\", default=True, show_default=True)\ndef post_yt_playlist_cli(\n    lang: str,\n    course_id: int,\n    playlist_url: str,\n    skip_uploaded: bool,\n) -&gt; None:\n    \"\"\"Post a youtube playlist.\"\"\"\n    post_yt_playlist(\n        lang,\n        course_id,\n        playlist_url,\n        skip_uploaded=skip_uploaded,\n        skip_no_cc=True,\n    )\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.merge_cli","title":"merge_cli","text":"<pre><code>merge_cli(lang: str, fr_course_id: int, to_course_id: int) -&gt; None\n</code></pre> <p>Merge courses.</p> <p>Merge all the lessons in course FR into course TO.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"merge\")\n@click.argument(\"lang\")\n@click.argument(\"fr_course_id\")\n@click.argument(\"to_course_id\")\ndef merge_cli(lang: str, fr_course_id: int, to_course_id: int) -&gt; None:\n    \"\"\"Merge courses.\n\n    Merge all the lessons in course FR into course TO.\n    \"\"\"\n    merge(lang, fr_course_id, to_course_id)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.reindex_cli","title":"reindex_cli","text":"<pre><code>reindex_cli(lang: str, course_id: int, dry_run: bool) -&gt; None\n</code></pre> <p>Reindex titles in a course.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"reindex\")\n@click.argument(\"lang\")\n@click.argument(\"course_id\")\n@dry_run_option()\ndef reindex_cli(lang: str, course_id: int, dry_run: bool) -&gt; None:\n    \"\"\"Reindex titles in a course.\"\"\"\n    reindex(lang, course_id, dry_run=dry_run)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.patch","title":"patch","text":"<pre><code>patch() -&gt; None\n</code></pre> <p>Patch commands.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.group()\ndef patch() -&gt; None:\n    \"\"\"Patch commands.\"\"\"\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.patch_audios_cli","title":"patch_audios_cli","text":"<pre><code>patch_audios_cli(lang: str, course_id: int, audios_folder: str) -&gt; None\n</code></pre> <p>Patch a course audio.</p> Source code in <code>src/cli.py</code> <pre><code>@patch.command(\"audios\")\n@click.argument(\"lang\")\n@click.argument(\"course_id\")\n@click.option(\n    \"--audios-folder\",\n    \"-a\",\n    default=DEFAULT_AUDIOS_FOLDER,\n    type=click.Path(exists=True, path_type=Path),\n    help=\"Audios folder path.\",\n)\ndef patch_audios_cli(lang: str, course_id: int, audios_folder: str) -&gt; None:\n    \"\"\"Patch a course audio.\"\"\"\n    patch_audios(lang, course_id, audios_folder)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.patch_texts_cli","title":"patch_texts_cli","text":"<pre><code>patch_texts_cli() -&gt; None\n</code></pre> <p>Not implemented.</p> Source code in <code>src/cli.py</code> <pre><code>@patch.command(\"texts\")\ndef patch_texts_cli() -&gt; None:\n    \"\"\"Not implemented.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.replace_ja_cli","title":"replace_ja_cli","text":"<pre><code>replace_ja_cli(course_id: int, choice: str) -&gt; None\n</code></pre> <p>Replace words in a course (only for japanese).</p> <p>This is a hack to fix a bug on LingQ's side. Do not use.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"replace\")\n@click.argument(\"course_id\")\n@click.argument(\"choice\", type=click.Choice([\"fst\", \"snd\"]))\ndef replace_ja_cli(course_id: int, choice: str) -&gt; None:\n    \"\"\"Replace words in a course (only for japanese).\n\n    This is a hack to fix a bug on LingQ's side. Do not use.\n    \"\"\"\n\n    # TODO: delete this... I'm tired to fix their own issues...\n    _to_ignore = \"\u300e\u300f\u300c\u300d\"\n    repl_ja = {k: f\"DUMMY{idx}\" for idx, k in enumerate(_to_ignore)}\n    repl_ja_inv = {v: k for k, v in repl_ja.items()}\n    replacements = repl_ja if choice == \"fst\" else repl_ja_inv\n    replace(\"ja\", course_id, replacements)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.resplit_ja_cli","title":"resplit_ja_cli","text":"<pre><code>resplit_ja_cli(course_id: int) -&gt; None\n</code></pre> <p>Resplit words in a course (only for japanese).</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"resplit\")\n@click.argument(\"course_id\")\ndef resplit_ja_cli(course_id: int) -&gt; None:\n    \"\"\"Resplit words in a course (only for japanese).\"\"\"\n    resplit(course_id)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.stats_cli","title":"stats_cli","text":"<pre><code>stats_cli(lang: str) -&gt; None\n</code></pre> <p>Show some simple stats.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"stats\")\n@click.argument(\"lang\")\ndef stats_cli(lang: str) -&gt; None:\n    \"\"\"Show some simple stats.\"\"\"\n    stats(lang)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.markdown_cli","title":"markdown_cli","text":"<pre><code>markdown_cli(langs: list[str], select_courses: str, include_views: bool, opath: Path) -&gt; None\n</code></pre> <p>Generate markdown files for the given language codes.</p> <p>If no language codes are given, use all languages.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"markdown\")\n@click.argument(\"langs\", nargs=-1)\n@click.option(\n    \"--select-courses\",\n    default=\"all\",\n    show_default=True,\n    type=click.Choice([\"all\", \"mine\", \"shared\"]),\n    help=\"Select which courses to include.\",\n)\n@click.option(\n    \"--include-views\",\n    is_flag=True,\n    default=False,\n    show_default=True,\n    help=\"Include the number of views in the markdown.\",\n)\n@opath_option()\ndef markdown_cli(\n    langs: list[str],\n    select_courses: str,\n    include_views: bool,\n    opath: Path,\n) -&gt; None:\n    \"\"\"Generate markdown files for the given language codes.\n\n    If no language codes are given, use all languages.\n    \"\"\"\n    markdown(langs, select_courses, include_views, opath)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.generate_timestamps_cli","title":"generate_timestamps_cli","text":"<pre><code>generate_timestamps_cli(lang: str, course_id: int, skip_timestamped: bool) -&gt; None\n</code></pre> <p>Generate timestamps for a course.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"timestamp\")\n@click.argument(\"lang\")\n@click.argument(\"course_id\")\n@click.option(\"--skip-timestamped\", default=True)\ndef generate_timestamps_cli(lang: str, course_id: int, skip_timestamped: bool) -&gt; None:\n    \"\"\"Generate timestamps for a course.\"\"\"\n    generate_timestamps(lang, course_id, skip_timestamped)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.overview_cli","title":"overview_cli","text":"<pre><code>overview_cli(lang: str) -&gt; None\n</code></pre> <p>Library overview.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"overview\")\n@click.argument(\"lang\")\ndef overview_cli(lang: str) -&gt; None:\n    \"\"\"Library overview.\"\"\"\n    overview(lang)\n</code></pre>"},{"location":"api-reference/generated/cli/#cli.sort_lessons_cli","title":"sort_lessons_cli","text":"<pre><code>sort_lessons_cli(lang: str, course_id: int, dry_run: bool) -&gt; None\n</code></pre> <p>Sort all lessons from a course.</p> Source code in <code>src/cli.py</code> <pre><code>@cli.command(\"sort\")\n@click.argument(\"lang\")\n@click.argument(\"course_id\")\n@dry_run_option()\ndef sort_lessons_cli(lang: str, course_id: int, dry_run: bool) -&gt; None:\n    \"\"\"Sort all lessons from a course.\"\"\"\n    sort_lessons(lang, course_id, dry_run=dry_run)\n</code></pre>"},{"location":"api-reference/generated/config/","title":"config","text":""},{"location":"api-reference/generated/config/#config","title":"config","text":""},{"location":"api-reference/generated/lingqhandler/","title":"lingqhandler","text":""},{"location":"api-reference/generated/lingqhandler/#lingqhandler","title":"lingqhandler","text":""},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler","title":"LingqHandler","text":"<p>Abstraction for the requests sent to the LingQ API.</p> A collection is a course in the API lingo, i.e. a group of lessons. <p>For consistency, 'course_id' is prefered over 'collection_id'.</p> <p>Attributes:</p> Name Type Description <code>lang</code> <code>str</code> <p>The language code for the course (e.g., 'ja' for Japanese).</p> <code>config</code> <code>Config</code> <p>Configuration settings for the LingQ API.</p> <code>session</code> <code>RetryClient</code> <p>A retry-enabled HTTP client session.</p> <code>_user_id</code> <code>int | None</code> <p>The user id. Used for some requests.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>class LingqHandler:\n    \"\"\"Abstraction for the requests sent to the LingQ API.\n\n    NOTE: A collection is a course in the API lingo, i.e. a group of lessons.\n          For consistency, 'course_id' is prefered over 'collection_id'.\n\n    Attributes:\n        lang (str): The language code for the course (e.g., 'ja' for Japanese).\n        config (Config): Configuration settings for the LingQ API.\n        session (RetryClient): A retry-enabled HTTP client session.\n        _user_id (int | None): The user id. Used for some requests.\n\n    \"\"\"\n\n    API_URL_V1 = \"https://www.lingq.com/api\"\n    API_URL_V2 = \"https://www.lingq.com/api/v2\"\n    API_URL_V3 = \"https://www.lingq.com/api/v3\"\n\n    def __init__(self, lang: str) -&gt; None:\n        self.lang = lang\n        self.config = Config()\n        retry_client = RetryClient(\n            client_session=ClientSession(),\n            raise_for_status=False,\n            retry_options=ExponentialRetry(attempts=3),\n        )\n        self.session = retry_client\n        self._user_id = None\n\n    async def __aenter__(self):  # noqa: ANN204\n        return self\n\n    async def __aexit__(self, *_):  # noqa: ANN002, ANN204\n        await self.session.close()\n\n    \"\"\"Debug utils\"\"\"\n\n    async def _options(self, url: str) -&gt; Any:\n        async with self.session.options(url, headers=self.config.headers) as response:\n            return await response.json()\n\n    async def response_debug(self, response: ClientResponse) -&gt; None:  # noqa: C901\n        match response.status:\n            case 524:\n                logger.error(\"LingQ's servers are overloaded: cloudflare timeout (&gt; 100 secs).\")\n            case 429:\n                logger.error(\"Rate limited! Slow down and retry in a couple minutes.\")\n            case 409:\n                logger.warning(\"Conflict. Generating timestamps / splitting twice?\")\n                # Do not print the response text for this error\n                return\n            case 405:\n                logger.warning(\"Timestamps are already being generated...\")\n            case 404:\n                # Not found error.\n                pass\n            case 401:\n                # Invalid APIKEY.\n                pass\n            case 400:\n                # Generic error. Happens for multiple reasons.\n                pass\n            case _:\n                logger.error(f\"Unhandled response code error: {response.status}\")\n\n        if response.headers.get(\"Content-Type\") == \"application/json\":\n            response_json = await response.json()\n            if isinstance(response_json, dict):\n                match response_json.get(\"detail\", \"_SENTINEL\"):\n                    case \"_SENTINEL\":\n                        pass\n                    case \"Invalid token.\":\n                        logger.error(\"Invalid API key. Exiting.\")\n                        sys.exit(1)\n                    case _:\n                        logger.error(\"Uncaught detail\")\n            logger.error(f\"[{response.status}] Response JSON:\\n{response_json}\")\n        else:\n            logger.error(f\"Response text: {response.text}\")\n\n    \"\"\"Generic request\"\"\"\n\n    async def _request(\n        self,\n        method: str,\n        endpoint: str,\n        *,\n        version: int = 3,\n        add_language: bool = True,\n        raw: bool = False,\n        retry_on_locked: bool = False,\n        **kwargs,  # noqa: ANN003\n    ) -&gt; Any:\n        api_url = {\n            1: LingqHandler.API_URL_V1,\n            2: LingqHandler.API_URL_V2,\n            3: LingqHandler.API_URL_V3,\n        }[version]\n\n        if add_language:\n            url = f\"{api_url}/{self.lang}/{endpoint}\"\n        else:\n            url = f\"{api_url}/{endpoint}\"\n\n        logger.trace(f\"{method.upper()} {url}\")\n        if params := kwargs.get(\"params\", \"\"):\n            logger.trace(f\"{params=}\")\n\n        if not retry_on_locked:\n            return await self._send_request(method, url, raw=raw, **kwargs)\n        else:\n            assert raw is False, \"Raw must be false when retrying on locked\"\n            return await self._send_request_retry(method, url, raw=False, **kwargs)\n\n    async def _send_request(\n        self,\n        method: str,\n        url: str,\n        *,\n        raw: bool,\n        quiet: bool = False,\n        **kwargs,  # noqa: ANN003\n    ) -&gt; Any:\n        meth = getattr(self.session, method.lower())\n        async with meth(url, headers=self.config.headers, **kwargs) as response:\n            if not 200 &lt;= response.status &lt; 300:\n                if not quiet:\n                    await self.response_debug(response)\n                return response\n            if raw:\n                return response\n            return await response.json()\n\n    async def _send_request_retry(\n        self,\n        method: str,\n        url: str,\n        *,\n        raw: bool,\n        max_retries: int = 4,\n        **kwargs,  # noqa: ANN003\n    ) -&gt; Any:\n        \"\"\"On locked error, retry 'max_retries' times.\n\n        That is, loop until we get a JSON result that does not look like this:\n        * {'isLocked': 'TOKENIZE_TEXT', 'errorType': 'locked'}\n        * {'isLocked': 'GENERATE_TIMESTAMPS', 'errorType': 'locked'}\n        \"\"\"\n        for retry in range(1, max_retries + 1):\n            response = await self._send_request(method, url, raw=raw, quiet=True, **kwargs)\n            # If _send_request:\n            # * failed:    response is a ClientResponse.\n            # * succeeded: response was already converted to a json.\n            if isinstance(response, ClientResponse):\n                response = await response.json()\n            if response.get(\"errorType\", \"\") != \"locked\":\n                return response\n\n            locked_reason = response[\"isLocked\"]\n            if locked_reason not in LOCKED_REASON_CHOICES:\n                logger.warning(f\"Unexpected lock reason: {locked_reason}\")\n            logger.debug(\n                f\"Content is locked at {locked_reason}. Retrying... ({retry}/{max_retries})\"\n            )\n            await asyncio.sleep(2**retry)\n\n        raise RuntimeError(\"Content is locked.\")\n\n    \"\"\"Get requests\"\"\"\n\n    async def get_user_id(self) -&gt; None:\n        \"\"\"Get and cache the user id.\"\"\"\n        if self._user_id is None:\n            data = await self._request(\"GET\", \"profile/\", version=1, add_language=False)\n            self._user_id = data[\"id\"]\n            logger.trace(f\"Cached user id {self._user_id}\")\n\n    async def _get_user_langs(self) -&gt; list[str]:\n        \"\"\"Get a list of language codes with known words.\n\n        https://www.lingq.com/apidocs/api-2.0.html#get\n        \"\"\"\n        data = await self._request(\"GET\", \"languages\", version=2, add_language=False)\n        return [lc[\"code\"] for lc in data if lc[\"knownWords\"] &gt; 0]\n\n    @classmethod\n    def get_user_langs(cls) -&gt; list[str]:\n        \"\"\"Get a list of language codes with known words.\n\n        This is a class method since it does not require initializing a language code.\n        \"\"\"\n\n        async def get_user_langs_tmp() -&gt; list[str]:\n            async with cls(\"Filler\") as handler:\n                return await handler._get_user_langs()\n\n        return asyncio.run(get_user_langs_tmp())\n\n    async def get_lesson_from_id(self, lesson_id: int) -&gt; LessonV3:\n        \"\"\"Get a lesson, from its id.\n\n        Example:\n            id: 34754329\n            url: https://www.lingq.com/api/v3/LANG/lessons/ID/\n\n        \"\"\"\n        data = await self._request(\n            \"GET\",\n            f\"lessons/{lesson_id}/\",\n            retry_on_locked=True,\n        )\n        return LessonV3.model_validate(data)\n\n    async def get_lesson_from_ids(self, ids: list[int]) -&gt; list[LessonV3]:\n        \"\"\"Get a list of lessons, from their ids.\"\"\"\n        return await asyncio.gather(*(self.get_lesson_from_id(id) for id in ids))\n\n    async def get_collection_lessons_from_id(self, course_id: int) -&gt; list[CollectionLessonResult]:\n        \"\"\"Get a list of lessons, from their collection id.\n\n        Example:\n            id: 537808\n            url: https://www.lingq.com/api/v3/ja/collections/537808/lessons\n\n        \"\"\"\n        base_url_size = len(f\"{LingqHandler.API_URL_V3}/{self.lang}/\")\n        url = f\"{LingqHandler.API_URL_V3}/{self.lang}/collections/{course_id}/lessons/\"\n        collection_lessons = []\n        cur_url = url\n\n        while cur_url:\n            endpoint = cur_url[base_url_size:]\n            res_json = await self._request(\"GET\", endpoint)\n            collection_lessons_at_page = CollectionLessons.model_validate(res_json)\n            collection_lessons.extend(collection_lessons_at_page.results)\n            cur_url = collection_lessons_at_page.next\n\n        if collection_lessons.count == 0:\n            editor_url = get_editor_url(self.lang, course_id, \"course\")\n            logger.warning(\n                f\" The collection {course_id} at {editor_url} has no lessons, (delete it?)\"\n            )\n\n        return collection_lessons\n\n    async def get_my_collections(self) -&gt; MyCollections:\n        data = await self._request(\"GET\", \"collections/my\")\n        if isinstance(data, ClientResponse):\n            # Error occurred (e.g., 404 for invalid language)\n            logger.error(f\"Failed to get collections for language '{self.lang}'\")\n            sys.exit(1)\n        return MyCollections.model_validate(data)\n\n    async def counters(self, collection_ids: list[int]) -&gt; dict[str, Counter]:\n        \"\"\"Return summary information about collections.\"\"\"\n        params = {\"collection\": collection_ids}\n        data = await self._request(\"GET\", \"collections/counters/\", params=params)\n        return {\n            collection_id: model_validate_or_exit(\n                Counter, counter, self.lang, collection_id, \"course\"\n            )\n            for collection_id, counter in data.items()\n        }\n\n    async def search(self, params: dict[str, Any]) -&gt; SearchCollections:\n        data = await self._request(\"GET\", \"search\", params=params)\n        return SearchCollections.model_validate(data)\n\n    async def get_my_collections_shared(self) -&gt; list[SearchCollectionResult]:\n        await self.get_user_id()\n        data = await self.search(\n            {\"type\": \"collection\", \"sharedBy\": str(self._user_id), \"sortBy\": \"recentlyOpened\"}\n        )\n        return data.results\n\n    async def get_currently_studying_collections(self) -&gt; list[SearchCollectionResult]:\n        \"\"\"Get collections from the 'Continue Studying shelf'.\n\n        This includes collections imported by other users.\n        \"\"\"\n        data = await self.search(\n            {\"shelf\": \"my_lessons\", \"type\": \"collection\", \"sortBy\": \"recentlyOpened\"}\n        )\n        return data.results\n\n    async def get_collection_from_id(self, course_id: int) -&gt; CollectionV3:\n        \"\"\"Get a CollectionV3 object.\n\n        This only contains an overview of the collection.\n        \"\"\"\n        data = await self._request(\"GET\", f\"collections/{course_id}\")\n        return CollectionV3.model_validate(data)\n\n    async def get_collection_from_id_v2(self, course_id: int) -&gt; Any:\n        \"\"\"Get a raw JSON for a collection (v2 API).\n\n        TODO: make a model for it.\n        \"\"\"\n        return await self._request(\"GET\", f\"collections/{course_id}\", version=2)\n\n    async def get_collection_object_from_id(self, course_id: int) -&gt; Collection | None:\n        \"\"\"Get a custom Collection object from a course_id.\n\n        Used for markdown generation.\n        \"\"\"\n        collection = await self.get_collection_from_id_v2(course_id)\n        if not collection:\n            return None\n        if collection.get(\"detail\", \"\") == \"Not found.\":\n            logger.warning(f\"Ghost course at: {get_editor_url(self.lang, course_id, 'course')}\")\n            return None\n        col = Collection()\n        col.add_data(self.lang, collection)\n        return col\n\n    async def get_audio_from_lesson(self, lesson: LessonV3) -&gt; bytes | None:\n        \"\"\"Get the audio from a lesson. Return None if there is no audio.\n\n        Note: The key with the audio url is 'audio' in V2 and 'audioUrl' in V3.\n        \"\"\"\n        if not lesson.audio_url:\n            return None\n        async with self.session.get(str(lesson.audio_url)) as response:\n            return await response.read()\n\n    async def get_stats(self) -&gt; Any:\n        \"\"\"Get reading stats for the last 7 days.\n\n        Period options can be found at (replace lang if needed):\n        https://www.lingq.com/api/v3/ja/progress/\n        \"\"\"\n        return await self._request(\n            method=\"GET\",\n            endpoint=\"progress/chart_data/?metric=reading&amp;period=last_7d\",\n        )\n\n    \"\"\"Patch requests\"\"\"\n\n    async def patch_audio(self, lesson_id: int, audio: BufferedReader) -&gt; ClientResponse:\n        \"\"\"PATCH. Replace the audio of a lesson.\"\"\"\n        return await self._request(\n            \"PATCH\", f\"lessons/{lesson_id}/\", data={\"audio\": audio}, raw=True\n        )\n\n    async def patch_text(self, lesson_id: int, text_data: str) -&gt; Any:\n        \"\"\"POST. Replace the text of a lesson.\n\n        Note that this is actually a POST request that works like a patch one.\n        \"\"\"\n        return await self._request(\n            \"POST\", f\"lessons/{lesson_id}/resplit/\", data={\"text\": text_data}\n        )\n\n    async def patch_position(self, lesson_id: int, new_position: int) -&gt; Any:\n        \"\"\"PATCH. Replace the position of a lesson in its course.\"\"\"\n        return await self._request(\"PATCH\", f\"lessons/{lesson_id}\", data={\"pos\": new_position})\n\n    async def patch_course(self, lesson_id: int, new_course_id: int) -&gt; Any:\n        \"\"\"PATCH. Move a lesson to another course.\"\"\"\n        return await self._request(\n            \"PATCH\", f\"lessons/{lesson_id}\", data={\"collection\": new_course_id}\n        )\n\n    async def generate_timestamps(self, lesson_id: int) -&gt; Any:\n        \"\"\"POST. Add timestamps to a lesson.\"\"\"\n        return await self._request(\"POST\", f\"lessons/{lesson_id}/genaudio/\")\n\n    async def _create_course(self, data: dict[str, Any]) -&gt; Any:\n        \"\"\"POST. Create a course.\"\"\"\n        return await self._request(\"POST\", \"collections/\", data=data)\n\n    async def create_course(self, title: str, description: str = \"\") -&gt; Any:\n        \"\"\"Create an empty course given its title and (optional) description.\n\n        Returns the response JSON, which contains an entry \"id\" for the course id.\n        This id can be used for further uploading through post methods.\n        \"\"\"\n        return await self._create_course({\"title\": title, \"description\": description})\n\n    async def post_from_multipart(self, data: FormData, *, raw: bool = False) -&gt; Any:\n        return await self._request(\"POST\", \"lessons/import/\", data=data, raw=raw)\n\n    async def post_from_data_dict(self, data: dict[str, Any], *, raw: bool = False) -&gt; Any:\n        \"\"\"POST. Post a lesson from a dictionary.\n\n        F.e.\n            data = {\n                \"title\": \"tmp_title\",\n                \"text\": \"Hello, world!\",\n                \"status\": \"private\",  # default\n                \"level\": 0,           # default\n                \"collection\": course_id,\n                \"save\": True,         # Needed\n            }\n        \"\"\"\n        self._check_data_conv(data)\n        fdata = FormData(data)\n        return await self.post_from_multipart(fdata, raw=raw)\n\n    def _check_data_conv(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"Verify that we have the keys needed by LingQ.\"\"\"\n        needed_keys = {\"title\", \"collection\", \"save\"}\n        need_one_of = {\"text\", \"url\"}\n        keys = set(data.keys())\n        if not keys &amp; need_one_of:\n            raise ValueError(f\"Data needs at least one entry in {need_one_of}\")\n        for key in needed_keys:\n            if key not in data:\n                raise ValueError(f\"Error at post_from_data_dict: data has no {key=}\")\n\n    async def replace(self, lesson_id: int, replacements: dict[str, str]) -&gt; ClientResponse:\n        \"\"\"POST. Regex-like replace text in a lesson.\n\n        A replacement is a pair {regex: substition}. F.e. {\"a\": \"b\", \"c\": \"d\"}\n        I'm aware that the first argument is a regex because of the error messages\n        with the '[]' characters, but I haven't actually used it with a regex.\n\n        This does not use _post because it requires the data to be sent as json.\n        \"\"\"\n        return await self._request(\n            \"POST\",\n            f\"lessons/{lesson_id}/sentences/\",\n            json={\"action\": \"replace\", \"text\": replacements},\n            raw=True,\n        )\n\n    async def replace_sentence(self, lesson_id: int, text: str, index: int) -&gt; ClientResponse:\n        \"\"\"POST. Replace a sentence in a lesson.\"\"\"\n        return await self._request(\n            \"POST\",\n            f\"lessons/{lesson_id}/sentences/\",\n            json={\"action\": \"update\", \"index\": index, \"text\": text},\n            raw=True,\n        )\n\n    async def _has_title_paragraph(self, lesson_id: int) -&gt; bool:\n        \"\"\"This is awful and I am convinced it is exactly what LingQ does internally.\"\"\"\n        paragraphs = await self._request(\"GET\", f\"lessons/{lesson_id}/paragraphs/\")\n        has_title = paragraphs and (paragraphs[0].get(\"style\", \"\") == \"h1\")\n        if not has_title:\n            # Issue a warning since you probably always want a title paragraph\n            editor_url = get_editor_url(self.lang, lesson_id, \"lesson\")\n            logger.warning(f\"Missing title paragraph at lesson @ {editor_url}\")\n        return has_title\n\n    async def replace_title(self, lesson_id: int, text: str) -&gt; ClientResponse:\n        \"\"\"POST/PATCH. Replace the title of a lesson.\"\"\"\n        has_title = await self._has_title_paragraph(lesson_id)\n        if has_title:\n            # Works if the first line is TITLE\n            return await self.replace_sentence(lesson_id, text, index=1)\n        else:\n            # Works if the first line is PARAGRAPH 1 (~~no title, f.e. youtube import)\n            # Does not modify the first sentence, but then again, there is no guarantee that\n            # we _want_ to modify the first sentence, since it may not be the title...\n            return await self._request(\"PATCH\", f\"lessons/{lesson_id}\", data={\"title\": text})\n\n    async def resplit_lesson(self, lesson_id: int, method: str) -&gt; ClientResponse:\n        \"\"\"Resplit a Japanese lesson using the new splitting logic.\n\n        https://forum.lingq.com/t/refining-parsing-in-spaceless-languages-like-japanese-with-ai/179754/5\n        \"\"\"\n        if method != \"ichimoe\":\n            msg = \"Only method=ichimoe is supported.\"\n            raise NotImplementedError(msg)\n        return await self._request(\n            \"POST\",\n            f\"lessons/{lesson_id}/resplit/\",\n            data={\"method\": method},\n            raw=True,\n        )\n\n    async def delete_course(self, course_id: int) -&gt; None:\n        \"\"\"Delete a course.\n\n        Crashes if the course is not succesfully deleted.\n        \"\"\"\n        url = f\"{LingqHandler.API_URL_V3}/{self.lang}/collections/{course_id}\"\n        async with self.session.delete(url, headers=self.config.headers) as response:\n            if response.status != 202:\n                msg = \"The course could not be successfully deleted\"\n                raise RuntimeError(msg)\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_user_id","title":"get_user_id  <code>async</code>","text":"<pre><code>get_user_id() -&gt; None\n</code></pre> <p>Get and cache the user id.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_user_id(self) -&gt; None:\n    \"\"\"Get and cache the user id.\"\"\"\n    if self._user_id is None:\n        data = await self._request(\"GET\", \"profile/\", version=1, add_language=False)\n        self._user_id = data[\"id\"]\n        logger.trace(f\"Cached user id {self._user_id}\")\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_user_langs","title":"get_user_langs  <code>classmethod</code>","text":"<pre><code>get_user_langs() -&gt; list[str]\n</code></pre> <p>Get a list of language codes with known words.</p> <p>This is a class method since it does not require initializing a language code.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>@classmethod\ndef get_user_langs(cls) -&gt; list[str]:\n    \"\"\"Get a list of language codes with known words.\n\n    This is a class method since it does not require initializing a language code.\n    \"\"\"\n\n    async def get_user_langs_tmp() -&gt; list[str]:\n        async with cls(\"Filler\") as handler:\n            return await handler._get_user_langs()\n\n    return asyncio.run(get_user_langs_tmp())\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_lesson_from_id","title":"get_lesson_from_id  <code>async</code>","text":"<pre><code>get_lesson_from_id(lesson_id: int) -&gt; LessonV3\n</code></pre> <p>Get a lesson, from its id.</p> Example <p>id: 34754329 url: https://www.lingq.com/api/v3/LANG/lessons/ID/</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_lesson_from_id(self, lesson_id: int) -&gt; LessonV3:\n    \"\"\"Get a lesson, from its id.\n\n    Example:\n        id: 34754329\n        url: https://www.lingq.com/api/v3/LANG/lessons/ID/\n\n    \"\"\"\n    data = await self._request(\n        \"GET\",\n        f\"lessons/{lesson_id}/\",\n        retry_on_locked=True,\n    )\n    return LessonV3.model_validate(data)\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_lesson_from_ids","title":"get_lesson_from_ids  <code>async</code>","text":"<pre><code>get_lesson_from_ids(ids: list[int]) -&gt; list[LessonV3]\n</code></pre> <p>Get a list of lessons, from their ids.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_lesson_from_ids(self, ids: list[int]) -&gt; list[LessonV3]:\n    \"\"\"Get a list of lessons, from their ids.\"\"\"\n    return await asyncio.gather(*(self.get_lesson_from_id(id) for id in ids))\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_collection_lessons_from_id","title":"get_collection_lessons_from_id  <code>async</code>","text":"<pre><code>get_collection_lessons_from_id(course_id: int) -&gt; list[CollectionLessonResult]\n</code></pre> <p>Get a list of lessons, from their collection id.</p> Example <p>id: 537808 url: https://www.lingq.com/api/v3/ja/collections/537808/lessons</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_collection_lessons_from_id(self, course_id: int) -&gt; list[CollectionLessonResult]:\n    \"\"\"Get a list of lessons, from their collection id.\n\n    Example:\n        id: 537808\n        url: https://www.lingq.com/api/v3/ja/collections/537808/lessons\n\n    \"\"\"\n    base_url_size = len(f\"{LingqHandler.API_URL_V3}/{self.lang}/\")\n    url = f\"{LingqHandler.API_URL_V3}/{self.lang}/collections/{course_id}/lessons/\"\n    collection_lessons = []\n    cur_url = url\n\n    while cur_url:\n        endpoint = cur_url[base_url_size:]\n        res_json = await self._request(\"GET\", endpoint)\n        collection_lessons_at_page = CollectionLessons.model_validate(res_json)\n        collection_lessons.extend(collection_lessons_at_page.results)\n        cur_url = collection_lessons_at_page.next\n\n    if collection_lessons.count == 0:\n        editor_url = get_editor_url(self.lang, course_id, \"course\")\n        logger.warning(\n            f\" The collection {course_id} at {editor_url} has no lessons, (delete it?)\"\n        )\n\n    return collection_lessons\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.counters","title":"counters  <code>async</code>","text":"<pre><code>counters(collection_ids: list[int]) -&gt; dict[str, Counter]\n</code></pre> <p>Return summary information about collections.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def counters(self, collection_ids: list[int]) -&gt; dict[str, Counter]:\n    \"\"\"Return summary information about collections.\"\"\"\n    params = {\"collection\": collection_ids}\n    data = await self._request(\"GET\", \"collections/counters/\", params=params)\n    return {\n        collection_id: model_validate_or_exit(\n            Counter, counter, self.lang, collection_id, \"course\"\n        )\n        for collection_id, counter in data.items()\n    }\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_currently_studying_collections","title":"get_currently_studying_collections  <code>async</code>","text":"<pre><code>get_currently_studying_collections() -&gt; list[SearchCollectionResult]\n</code></pre> <p>Get collections from the 'Continue Studying shelf'.</p> <p>This includes collections imported by other users.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_currently_studying_collections(self) -&gt; list[SearchCollectionResult]:\n    \"\"\"Get collections from the 'Continue Studying shelf'.\n\n    This includes collections imported by other users.\n    \"\"\"\n    data = await self.search(\n        {\"shelf\": \"my_lessons\", \"type\": \"collection\", \"sortBy\": \"recentlyOpened\"}\n    )\n    return data.results\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_collection_from_id","title":"get_collection_from_id  <code>async</code>","text":"<pre><code>get_collection_from_id(course_id: int) -&gt; CollectionV3\n</code></pre> <p>Get a CollectionV3 object.</p> <p>This only contains an overview of the collection.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_collection_from_id(self, course_id: int) -&gt; CollectionV3:\n    \"\"\"Get a CollectionV3 object.\n\n    This only contains an overview of the collection.\n    \"\"\"\n    data = await self._request(\"GET\", f\"collections/{course_id}\")\n    return CollectionV3.model_validate(data)\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_collection_from_id_v2","title":"get_collection_from_id_v2  <code>async</code>","text":"<pre><code>get_collection_from_id_v2(course_id: int) -&gt; Any\n</code></pre> <p>Get a raw JSON for a collection (v2 API).</p> <p>TODO: make a model for it.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_collection_from_id_v2(self, course_id: int) -&gt; Any:\n    \"\"\"Get a raw JSON for a collection (v2 API).\n\n    TODO: make a model for it.\n    \"\"\"\n    return await self._request(\"GET\", f\"collections/{course_id}\", version=2)\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_collection_object_from_id","title":"get_collection_object_from_id  <code>async</code>","text":"<pre><code>get_collection_object_from_id(course_id: int) -&gt; Collection | None\n</code></pre> <p>Get a custom Collection object from a course_id.</p> <p>Used for markdown generation.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_collection_object_from_id(self, course_id: int) -&gt; Collection | None:\n    \"\"\"Get a custom Collection object from a course_id.\n\n    Used for markdown generation.\n    \"\"\"\n    collection = await self.get_collection_from_id_v2(course_id)\n    if not collection:\n        return None\n    if collection.get(\"detail\", \"\") == \"Not found.\":\n        logger.warning(f\"Ghost course at: {get_editor_url(self.lang, course_id, 'course')}\")\n        return None\n    col = Collection()\n    col.add_data(self.lang, collection)\n    return col\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_audio_from_lesson","title":"get_audio_from_lesson  <code>async</code>","text":"<pre><code>get_audio_from_lesson(lesson: LessonV3) -&gt; bytes | None\n</code></pre> <p>Get the audio from a lesson. Return None if there is no audio.</p> <p>Note: The key with the audio url is 'audio' in V2 and 'audioUrl' in V3.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_audio_from_lesson(self, lesson: LessonV3) -&gt; bytes | None:\n    \"\"\"Get the audio from a lesson. Return None if there is no audio.\n\n    Note: The key with the audio url is 'audio' in V2 and 'audioUrl' in V3.\n    \"\"\"\n    if not lesson.audio_url:\n        return None\n    async with self.session.get(str(lesson.audio_url)) as response:\n        return await response.read()\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.get_stats","title":"get_stats  <code>async</code>","text":"<pre><code>get_stats() -&gt; Any\n</code></pre> <p>Get reading stats for the last 7 days.</p> <p>Period options can be found at (replace lang if needed): https://www.lingq.com/api/v3/ja/progress/</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def get_stats(self) -&gt; Any:\n    \"\"\"Get reading stats for the last 7 days.\n\n    Period options can be found at (replace lang if needed):\n    https://www.lingq.com/api/v3/ja/progress/\n    \"\"\"\n    return await self._request(\n        method=\"GET\",\n        endpoint=\"progress/chart_data/?metric=reading&amp;period=last_7d\",\n    )\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.patch_audio","title":"patch_audio  <code>async</code>","text":"<pre><code>patch_audio(lesson_id: int, audio: BufferedReader) -&gt; ClientResponse\n</code></pre> <p>PATCH. Replace the audio of a lesson.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def patch_audio(self, lesson_id: int, audio: BufferedReader) -&gt; ClientResponse:\n    \"\"\"PATCH. Replace the audio of a lesson.\"\"\"\n    return await self._request(\n        \"PATCH\", f\"lessons/{lesson_id}/\", data={\"audio\": audio}, raw=True\n    )\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.patch_text","title":"patch_text  <code>async</code>","text":"<pre><code>patch_text(lesson_id: int, text_data: str) -&gt; Any\n</code></pre> <p>POST. Replace the text of a lesson.</p> <p>Note that this is actually a POST request that works like a patch one.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def patch_text(self, lesson_id: int, text_data: str) -&gt; Any:\n    \"\"\"POST. Replace the text of a lesson.\n\n    Note that this is actually a POST request that works like a patch one.\n    \"\"\"\n    return await self._request(\n        \"POST\", f\"lessons/{lesson_id}/resplit/\", data={\"text\": text_data}\n    )\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.patch_position","title":"patch_position  <code>async</code>","text":"<pre><code>patch_position(lesson_id: int, new_position: int) -&gt; Any\n</code></pre> <p>PATCH. Replace the position of a lesson in its course.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def patch_position(self, lesson_id: int, new_position: int) -&gt; Any:\n    \"\"\"PATCH. Replace the position of a lesson in its course.\"\"\"\n    return await self._request(\"PATCH\", f\"lessons/{lesson_id}\", data={\"pos\": new_position})\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.patch_course","title":"patch_course  <code>async</code>","text":"<pre><code>patch_course(lesson_id: int, new_course_id: int) -&gt; Any\n</code></pre> <p>PATCH. Move a lesson to another course.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def patch_course(self, lesson_id: int, new_course_id: int) -&gt; Any:\n    \"\"\"PATCH. Move a lesson to another course.\"\"\"\n    return await self._request(\n        \"PATCH\", f\"lessons/{lesson_id}\", data={\"collection\": new_course_id}\n    )\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.generate_timestamps","title":"generate_timestamps  <code>async</code>","text":"<pre><code>generate_timestamps(lesson_id: int) -&gt; Any\n</code></pre> <p>POST. Add timestamps to a lesson.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def generate_timestamps(self, lesson_id: int) -&gt; Any:\n    \"\"\"POST. Add timestamps to a lesson.\"\"\"\n    return await self._request(\"POST\", f\"lessons/{lesson_id}/genaudio/\")\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.create_course","title":"create_course  <code>async</code>","text":"<pre><code>create_course(title: str, description: str = '') -&gt; Any\n</code></pre> <p>Create an empty course given its title and (optional) description.</p> <p>Returns the response JSON, which contains an entry \"id\" for the course id. This id can be used for further uploading through post methods.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def create_course(self, title: str, description: str = \"\") -&gt; Any:\n    \"\"\"Create an empty course given its title and (optional) description.\n\n    Returns the response JSON, which contains an entry \"id\" for the course id.\n    This id can be used for further uploading through post methods.\n    \"\"\"\n    return await self._create_course({\"title\": title, \"description\": description})\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.post_from_data_dict","title":"post_from_data_dict  <code>async</code>","text":"<pre><code>post_from_data_dict(data: dict[str, Any], *, raw: bool = False) -&gt; Any\n</code></pre> <p>POST. Post a lesson from a dictionary.</p> <p>F.e.     data = {         \"title\": \"tmp_title\",         \"text\": \"Hello, world!\",         \"status\": \"private\",  # default         \"level\": 0,           # default         \"collection\": course_id,         \"save\": True,         # Needed     }</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def post_from_data_dict(self, data: dict[str, Any], *, raw: bool = False) -&gt; Any:\n    \"\"\"POST. Post a lesson from a dictionary.\n\n    F.e.\n        data = {\n            \"title\": \"tmp_title\",\n            \"text\": \"Hello, world!\",\n            \"status\": \"private\",  # default\n            \"level\": 0,           # default\n            \"collection\": course_id,\n            \"save\": True,         # Needed\n        }\n    \"\"\"\n    self._check_data_conv(data)\n    fdata = FormData(data)\n    return await self.post_from_multipart(fdata, raw=raw)\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.replace","title":"replace  <code>async</code>","text":"<pre><code>replace(lesson_id: int, replacements: dict[str, str]) -&gt; ClientResponse\n</code></pre> <p>POST. Regex-like replace text in a lesson.</p> <p>A replacement is a pair {regex: substition}. F.e. {\"a\": \"b\", \"c\": \"d\"} I'm aware that the first argument is a regex because of the error messages with the '[]' characters, but I haven't actually used it with a regex.</p> <p>This does not use _post because it requires the data to be sent as json.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def replace(self, lesson_id: int, replacements: dict[str, str]) -&gt; ClientResponse:\n    \"\"\"POST. Regex-like replace text in a lesson.\n\n    A replacement is a pair {regex: substition}. F.e. {\"a\": \"b\", \"c\": \"d\"}\n    I'm aware that the first argument is a regex because of the error messages\n    with the '[]' characters, but I haven't actually used it with a regex.\n\n    This does not use _post because it requires the data to be sent as json.\n    \"\"\"\n    return await self._request(\n        \"POST\",\n        f\"lessons/{lesson_id}/sentences/\",\n        json={\"action\": \"replace\", \"text\": replacements},\n        raw=True,\n    )\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.replace_sentence","title":"replace_sentence  <code>async</code>","text":"<pre><code>replace_sentence(lesson_id: int, text: str, index: int) -&gt; ClientResponse\n</code></pre> <p>POST. Replace a sentence in a lesson.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def replace_sentence(self, lesson_id: int, text: str, index: int) -&gt; ClientResponse:\n    \"\"\"POST. Replace a sentence in a lesson.\"\"\"\n    return await self._request(\n        \"POST\",\n        f\"lessons/{lesson_id}/sentences/\",\n        json={\"action\": \"update\", \"index\": index, \"text\": text},\n        raw=True,\n    )\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.replace_title","title":"replace_title  <code>async</code>","text":"<pre><code>replace_title(lesson_id: int, text: str) -&gt; ClientResponse\n</code></pre> <p>POST/PATCH. Replace the title of a lesson.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def replace_title(self, lesson_id: int, text: str) -&gt; ClientResponse:\n    \"\"\"POST/PATCH. Replace the title of a lesson.\"\"\"\n    has_title = await self._has_title_paragraph(lesson_id)\n    if has_title:\n        # Works if the first line is TITLE\n        return await self.replace_sentence(lesson_id, text, index=1)\n    else:\n        # Works if the first line is PARAGRAPH 1 (~~no title, f.e. youtube import)\n        # Does not modify the first sentence, but then again, there is no guarantee that\n        # we _want_ to modify the first sentence, since it may not be the title...\n        return await self._request(\"PATCH\", f\"lessons/{lesson_id}\", data={\"title\": text})\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.resplit_lesson","title":"resplit_lesson  <code>async</code>","text":"<pre><code>resplit_lesson(lesson_id: int, method: str) -&gt; ClientResponse\n</code></pre> <p>Resplit a Japanese lesson using the new splitting logic.</p> <p>https://forum.lingq.com/t/refining-parsing-in-spaceless-languages-like-japanese-with-ai/179754/5</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def resplit_lesson(self, lesson_id: int, method: str) -&gt; ClientResponse:\n    \"\"\"Resplit a Japanese lesson using the new splitting logic.\n\n    https://forum.lingq.com/t/refining-parsing-in-spaceless-languages-like-japanese-with-ai/179754/5\n    \"\"\"\n    if method != \"ichimoe\":\n        msg = \"Only method=ichimoe is supported.\"\n        raise NotImplementedError(msg)\n    return await self._request(\n        \"POST\",\n        f\"lessons/{lesson_id}/resplit/\",\n        data={\"method\": method},\n        raw=True,\n    )\n</code></pre>"},{"location":"api-reference/generated/lingqhandler/#lingqhandler.LingqHandler.delete_course","title":"delete_course  <code>async</code>","text":"<pre><code>delete_course(course_id: int) -&gt; None\n</code></pre> <p>Delete a course.</p> <p>Crashes if the course is not succesfully deleted.</p> Source code in <code>src/lingqhandler.py</code> <pre><code>async def delete_course(self, course_id: int) -&gt; None:\n    \"\"\"Delete a course.\n\n    Crashes if the course is not succesfully deleted.\n    \"\"\"\n    url = f\"{LingqHandler.API_URL_V3}/{self.lang}/collections/{course_id}\"\n    async with self.session.delete(url, headers=self.config.headers) as response:\n        if response.status != 202:\n            msg = \"The course could not be successfully deleted\"\n            raise RuntimeError(msg)\n</code></pre>"},{"location":"api-reference/generated/log/","title":"log","text":""},{"location":"api-reference/generated/log/#log","title":"log","text":""},{"location":"api-reference/generated/utils/","title":"utils","text":""},{"location":"api-reference/generated/utils/#utils","title":"utils","text":""},{"location":"api-reference/generated/utils/#utils.SortingMode","title":"SortingMode  <code>module-attribute</code>","text":"<pre><code>SortingMode = Literal['os', 'human', 'greek', 'roman']\n</code></pre> <p>List of sorted modes. Used for reading folder contents.</p>"},{"location":"api-reference/generated/utils/#utils.model_validate_or_exit","title":"model_validate_or_exit","text":"<pre><code>model_validate_or_exit(pydantic_model: Type[T], obj: Any, lang: str, content_id: int, content_type: ContentType) -&gt; T\n</code></pre> <p>Try to validate the pydantic model.</p> <p>In case of failure, log the error and exit the program. This makes debugging less cumbersome than to decypher the long async stacktrace.</p> Source code in <code>src/utils.py</code> <pre><code>def model_validate_or_exit[T: BaseModel](\n    pydantic_model: Type[T],\n    obj: Any,\n    lang: str,\n    content_id: int,\n    content_type: ContentType,\n) -&gt; T:\n    \"\"\"Try to validate the pydantic model.\n\n    In case of failure, log the error and exit the program. This makes\n    debugging less cumbersome than to decypher the long async stacktrace.\n    \"\"\"\n    try:\n        return pydantic_model.model_validate(obj)\n    except ValidationError as e:\n        message = (\n            f\"Error validating model for {content_type} with id {content_id}\\n\"\n            f\"Editor URL: {get_editor_url(lang, content_id, content_type)}\\n\"\n            f\"Details: {e}\"\n        )\n        logger.error(message)\n        sys.exit(1)\n</code></pre>"},{"location":"api-reference/generated/utils/#utils.normalize_greek_word","title":"normalize_greek_word","text":"<pre><code>normalize_greek_word(word: str) -&gt; str\n</code></pre> <p>Return a greek word without accents in lowercase. [\"\u0386\u03bb\u03c6\u03b1\", \"\u0391\u03bb\u03c6\u03b1\", \"\u03ac\u03bb\u03c6\u03b1\", \"\u03b1\u03bb\u03c6\u03b1\"] are all converted into \"\u03b1\u03bb\u03c6\u03b1\".</p> <p>words = [\"\u0386\u03bb\u03c6\u03b1\", \"\u0391\u03bb\u03c6\u03b1\", \"\u03ac\u03bb\u03c6\u03b1\", \"\u03b1\u03bb\u03c6\u03b1\"] normalized_words = [normalize_greek_word(w) for w in words] assert len(set(normalized_words)) == 1</p> Source code in <code>src/utils.py</code> <pre><code>def normalize_greek_word(word: str) -&gt; str:\n    \"\"\"Return a greek word without accents in lowercase.\n    [\"\u0386\u03bb\u03c6\u03b1\", \"\u0391\u03bb\u03c6\u03b1\", \"\u03ac\u03bb\u03c6\u03b1\", \"\u03b1\u03bb\u03c6\u03b1\"] are all converted into \"\u03b1\u03bb\u03c6\u03b1\".\n\n    &gt;&gt;&gt; words = [\"\u0386\u03bb\u03c6\u03b1\", \"\u0391\u03bb\u03c6\u03b1\", \"\u03ac\u03bb\u03c6\u03b1\", \"\u03b1\u03bb\u03c6\u03b1\"]\n    &gt;&gt;&gt; normalized_words = [normalize_greek_word(w) for w in words]\n    &gt;&gt;&gt; assert len(set(normalized_words)) == 1\n    \"\"\"\n    normalized = unicodedata.normalize(\"NFKD\", word).casefold()\n    return \"\".join(c for c in normalized if not unicodedata.combining(c))\n</code></pre>"},{"location":"api-reference/generated/utils/#utils.sort_by_greek_words_impl","title":"sort_by_greek_words_impl","text":"<pre><code>sort_by_greek_words_impl(word: str) -&gt; tuple[float, ...]\n</code></pre> <p>Sort greek words while ignoring case and accents.</p> <p>words = [\"\u0392\u03b5\u03bb\u03ac\u03ba\u03b9\", \"\u03ac\u03bb\u03c6\u03b1\", \"\u03b1\u03bb\u03c6\u03ac\u03b4\u03b9\", \"\u0386\u03c1\u03c4\u03b5\u03bc\u03b9\u03c2\", \"\u0386\u03bb\u03c6\u03b1\", \"\u03b1\u03bb\u03b5\u03c0\u03bf\u03cd\"] words.sort(key=sort_greek_words) [\"\u03b1\u03bb\u03b5\u03c0\u03bf\u03cd\", \"\u03ac\u03bb\u03c6\u03b1\", \"\u0386\u03bb\u03c6\u03b1\", \"\u03b1\u03bb\u03c6\u03ac\u03b4\u03b9\", \"\u0386\u03c1\u03c4\u03b5\u03bc\u03b9\u03c2\", \"\u0392\u03b5\u03bb\u03ac\u03ba\u03b9\"]</p> Source code in <code>src/utils.py</code> <pre><code>def sort_by_greek_words_impl(word: str) -&gt; tuple[float, ...]:\n    \"\"\"Sort greek words while ignoring case and accents.\n\n    &gt;&gt;&gt; words = [\"\u0392\u03b5\u03bb\u03ac\u03ba\u03b9\", \"\u03ac\u03bb\u03c6\u03b1\", \"\u03b1\u03bb\u03c6\u03ac\u03b4\u03b9\", \"\u0386\u03c1\u03c4\u03b5\u03bc\u03b9\u03c2\", \"\u0386\u03bb\u03c6\u03b1\", \"\u03b1\u03bb\u03b5\u03c0\u03bf\u03cd\"]\n    &gt;&gt;&gt; words.sort(key=sort_greek_words)\n    &gt;&gt;&gt; [\"\u03b1\u03bb\u03b5\u03c0\u03bf\u03cd\", \"\u03ac\u03bb\u03c6\u03b1\", \"\u0386\u03bb\u03c6\u03b1\", \"\u03b1\u03bb\u03c6\u03ac\u03b4\u03b9\", \"\u0386\u03c1\u03c4\u03b5\u03bc\u03b9\u03c2\", \"\u0392\u03b5\u03bb\u03ac\u03ba\u03b9\"]\n    \"\"\"\n    if not word:\n        return (float(\"inf\"),)\n    return tuple(ord(normalize_greek_word(char)) for char in word)\n</code></pre>"},{"location":"api-reference/generated/utils/#utils.get_sorting_fn","title":"get_sorting_fn","text":"<pre><code>get_sorting_fn(mode: SortingMode) -&gt; Callable[[str], Any]\n</code></pre> <p>Get the sorting function from a mode.</p> <p>Supports human (natsort), roman (I &lt; V) and greek (\u0392 &lt; \u0393) sorting.</p> Source code in <code>src/utils.py</code> <pre><code>def get_sorting_fn(mode: SortingMode) -&gt; Callable[[str], Any]:\n    \"\"\"Get the sorting function from a mode.\n\n    Supports human (natsort), roman (I &lt; V) and greek (\u0392 &lt; \u0393) sorting.\n    \"\"\"\n    sorting_fn: Callable[[str], Any]\n    match mode:\n        case \"os\":\n            # Sort elements in the same order as your operating system's file browser\n            # Note that this is platform-dependent\n            sorting_fn = os_sorted\n        case \"human\":\n            sorting_fn = natsort_keygen()\n        case \"greek\":\n            sorting_fn = greek_sorting_fn\n        case \"roman\":\n            sorting_fn = roman_sorting_fn\n    return sorting_fn\n</code></pre>"},{"location":"api-reference/generated/utils/#utils.sorted_subpaths","title":"sorted_subpaths","text":"<pre><code>sorted_subpaths(folder: Path, mode: SortingMode) -&gt; list[Path]\n</code></pre> <p>Returns subfolders sorted by sorting_fn.</p> Source code in <code>src/utils.py</code> <pre><code>def sorted_subpaths(folder: Path, mode: SortingMode) -&gt; list[Path]:\n    \"\"\"Returns subfolders sorted by sorting_fn.\"\"\"\n    sorting_fn = get_sorting_fn(mode)\n    subfolders = [sf for sf in folder.iterdir() if not sf.name.startswith(\".\")]\n    subfolders.sort(key=lambda x: sorting_fn(x.name))\n    return subfolders\n</code></pre>"},{"location":"api-reference/generated/commands/generate_timestamps/","title":"commands.generate_timestamps","text":""},{"location":"api-reference/generated/commands/generate_timestamps/#commands.generate_timestamps","title":"generate_timestamps","text":""},{"location":"api-reference/generated/commands/get_courses/","title":"commands.get_courses","text":""},{"location":"api-reference/generated/commands/get_courses/#commands.get_courses","title":"get_courses","text":""},{"location":"api-reference/generated/commands/get_courses/#commands.get_courses.get_courses","title":"get_courses","text":"<pre><code>get_courses(langs: list[str], opath: Path, *, download_audio: bool, download_timestamps: bool, skip_downloaded: bool, batch_size: int = 1) -&gt; None\n</code></pre> <p>Get every course from a list of languages.</p> <p>CAREFUL: This reorders your 'Continue studying' shelf.</p> Source code in <code>src/commands/get_courses.py</code> <pre><code>@timing\ndef get_courses(\n    langs: list[str],\n    opath: Path,\n    *,\n    download_audio: bool,\n    download_timestamps: bool,\n    skip_downloaded: bool,\n    batch_size: int = 1,\n) -&gt; None:\n    \"\"\"Get every course from a list of languages.\n\n    CAREFUL: This reorders your 'Continue studying' shelf.\n    \"\"\"\n    # If no language codes are given, use all languages.\n    if not langs:\n        langs = LingqHandler.get_user_langs()\n    asyncio.run(\n        get_courses_async(\n            langs,\n            opath,\n            download_audio=download_audio,\n            download_timestamps=download_timestamps,\n            skip_downloaded=skip_downloaded,\n            batch_size=batch_size,\n        )\n    )\n</code></pre>"},{"location":"api-reference/generated/commands/get_images/","title":"commands.get_images","text":""},{"location":"api-reference/generated/commands/get_images/#commands.get_images","title":"get_images","text":""},{"location":"api-reference/generated/commands/get_images/#commands.get_images.get_images","title":"get_images","text":"<pre><code>get_images(lang: str, course_id: int, opath: Path) -&gt; None\n</code></pre> <p>Get all images from a course.</p> Source code in <code>src/commands/get_images.py</code> <pre><code>@timing\ndef get_images(lang: str, course_id: int, opath: Path) -&gt; None:\n    \"\"\"Get all images from a course.\"\"\"\n    asyncio.run(get_images_async(lang, course_id, opath))\n</code></pre>"},{"location":"api-reference/generated/commands/get_lesson/","title":"commands.get_lesson","text":""},{"location":"api-reference/generated/commands/get_lesson/#commands.get_lesson","title":"get_lesson","text":""},{"location":"api-reference/generated/commands/get_lesson/#commands.get_lesson.get_lesson","title":"get_lesson","text":"<pre><code>get_lesson(lang: str, lesson_id: int, opath: Path, *, download_audio: bool, download_timestamps: bool) -&gt; None\n</code></pre> <p>Downloads text and/or audio from a lesson given the language code and the lesson ID.</p> Source code in <code>src/commands/get_lesson.py</code> <pre><code>@timing\ndef get_lesson(\n    lang: str,\n    lesson_id: int,\n    opath: Path,\n    *,\n    download_audio: bool,\n    download_timestamps: bool,\n) -&gt; None:\n    \"\"\"Downloads text and/or audio from a lesson given the language code and the lesson ID.\"\"\"\n\n    lesson = asyncio.run(\n        _get_lesson_async(\n            lang=lang,\n            lesson_id=lesson_id,\n            download_audio=download_audio,\n            download_timestamps=download_timestamps,\n        )\n    )\n    if lesson:\n        write_lesson(\n            lang=lang,\n            lesson=lesson,\n            opath=opath,\n            idx=None,\n        )\n        logger.success(f\"'{lesson.title}'\")\n</code></pre>"},{"location":"api-reference/generated/commands/get_lessons/","title":"commands.get_lessons","text":""},{"location":"api-reference/generated/commands/get_lessons/#commands.get_lessons","title":"get_lessons","text":""},{"location":"api-reference/generated/commands/get_lessons/#commands.get_lessons.get_lessons","title":"get_lessons","text":"<pre><code>get_lessons(lang: str, course_id: int, opath: Path, *, download_audio: bool, download_timestamps: bool, skip_downloaded: bool, write: bool, with_index: bool) -&gt; None\n</code></pre> <p>Downloads text and/or audio from a course given the language code and the course ID.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>str</code> <p>The language code of the course.</p> required <code>course_id</code> <code>str</code> <p>The ID of the course. This is the last number in the course URL.</p> required <code>opath</code> <code>Path</code> <p>Path to the folder where the downloaded text and audio files will be saved.</p> required <code>download_audio</code> <code>bool</code> <p>If True, downloads the audio files for the lessons.</p> required <code>download_timestamps</code> <code>bool</code> <p>If True, downloads the timestamps files for the lessons.</p> required <code>skip_downloaded</code> <code>bool</code> <p>If True, skip downloading already downloaded lessons.</p> required <code>TODO</code> <p>Update me</p> required <p>Creates a 'download' folder and saves the text/audio in 'text'/'audio' subfolders.</p> Source code in <code>src/commands/get_lessons.py</code> <pre><code>@timing\ndef get_lessons(\n    lang: str,\n    course_id: int,\n    opath: Path,\n    *,\n    download_audio: bool,\n    download_timestamps: bool,\n    skip_downloaded: bool,\n    write: bool,\n    with_index: bool,\n) -&gt; None:\n    \"\"\"Downloads text and/or audio from a course given the language code and the course ID.\n\n    Args:\n        lang (str): The language code of the course.\n        course_id (str): The ID of the course. This is the last number in the course URL.\n        opath (Path): Path to the folder where the downloaded text and audio files will be saved.\n\n        download_audio (bool): If True, downloads the audio files for the lessons.\n        download_timestamps (bool): If True, downloads the timestamps files for the lessons.\n        skip_downloaded (bool): If True, skip downloading already downloaded lessons.\n\n        TODO: Update me\n\n    Creates a 'download' folder and saves the text/audio in 'text'/'audio' subfolders.\n    \"\"\"\n    asyncio.run(\n        get_lessons_async(\n            lang,\n            course_id,\n            opath,\n            download_audio=download_audio,\n            download_timestamps=download_timestamps,\n            skip_downloaded=skip_downloaded,\n            write=write,\n            with_index=with_index,\n        )\n    )\n</code></pre>"},{"location":"api-reference/generated/commands/get_words/","title":"commands.get_words","text":""},{"location":"api-reference/generated/commands/get_words/#commands.get_words","title":"get_words","text":""},{"location":"api-reference/generated/commands/get_words/#commands.get_words.get_words_for_language_async","title":"get_words_for_language_async  <code>async</code>","text":"<pre><code>get_words_for_language_async(lang: str, page_size: int = 500) -&gt; WordDump\n</code></pre> <p>Get all LingQs for the given language.</p> The LingQ API clamps page size <ul> <li>The API default page_size is 100 (with a clamped max of 1000 words per page).</li> </ul> Source code in <code>src/commands/get_words.py</code> <pre><code>async def get_words_for_language_async(lang: str, page_size: int = 500) -&gt; WordDump:\n    \"\"\"Get all LingQs for the given language.\n\n    The LingQ API clamps page size:\n        - The API default page_size is 100 (with a clamped max of 1000 words per page).\n    \"\"\"\n    async with LingqHandler(lang) as handler:\n        url = f\"https://www.lingq.com/api/v3/{lang}/cards/\"\n        cur_url = f\"{url}?page=1&amp;page_size={page_size}\"\n        words: list[Card] = []\n        step = 1\n        total_pages = None\n\n        while cur_url:\n            async with handler.session.get(cur_url, headers=handler.config.headers) as response:\n                cards_json = await response.json()\n                cards = Cards.model_validate(cards_json)\n\n            if step == 1:\n                logger.info(f\"Getting {cards.count} lingqs for {lang}...\")\n                total_pages = ceil(cards.count / page_size)\n\n            words.extend(cards.results)\n            logger.info(f\"Progress: {step}/{total_pages} pages\")\n            logger.trace(cur_url)\n\n            cur_url = cards.next\n            step += 1\n            # await asyncio.sleep(1)\n\n        dump = [word.model_dump() for word in words]\n        return dump\n</code></pre>"},{"location":"api-reference/generated/commands/get_words/#commands.get_words.write_words_for_language","title":"write_words_for_language","text":"<pre><code>write_words_for_language(lang: str, opath: Path, dump: WordDump) -&gt; None\n</code></pre> <p>Write the word dump for a specific language.</p> Source code in <code>src/commands/get_words.py</code> <pre><code>def write_words_for_language(lang: str, opath: Path, dump: WordDump) -&gt; None:\n    \"\"\"Write the word dump for a specific language.\"\"\"\n    dump_folder_path = opath / \"lingqs\" / lang\n    Path.mkdir(dump_folder_path, parents=True, exist_ok=True)\n    dump_path = dump_folder_path / \"lingqs.json\"\n    with dump_path.open(\"w\") as f:\n        json.dump(dump, f, ensure_ascii=False, indent=2)\n    logger.success(f\"Wrote words at {dump_path}\")\n</code></pre>"},{"location":"api-reference/generated/commands/get_words/#commands.get_words.get_words","title":"get_words","text":"<pre><code>get_words(langs: list[str], opath: Path) -&gt; None\n</code></pre> <p>Get my words (LingQs) from a language.</p> Source code in <code>src/commands/get_words.py</code> <pre><code>@timing\ndef get_words(langs: list[str], opath: Path) -&gt; None:\n    \"\"\"Get my words (LingQs) from a language.\"\"\"\n    # If no language codes are given, use all languages.\n    if not langs:\n        langs = LingqHandler.get_user_langs()\n    logger.info(f\"Getting words for languages: {', '.join(langs)}\")\n    asyncio.run(get_words_async(langs, opath))\n</code></pre>"},{"location":"api-reference/generated/commands/library_overview/","title":"commands.library_overview","text":""},{"location":"api-reference/generated/commands/library_overview/#commands.library_overview","title":"library_overview","text":""},{"location":"api-reference/generated/commands/markdown/","title":"commands.markdown","text":""},{"location":"api-reference/generated/commands/markdown/#commands.markdown","title":"markdown","text":""},{"location":"api-reference/generated/commands/markdown/#commands.markdown.write_readme","title":"write_readme","text":"<pre><code>write_readme(langs: list[str], out_folder: Path) -&gt; None\n</code></pre> <p>Writes an index-like README.md.</p> <p>Adds links to the file structure for easy browsing: * Greek (el) * English (en) * French (fr) etc.</p> Source code in <code>src/commands/markdown.py</code> <pre><code>def write_readme(langs: list[str], out_folder: Path) -&gt; None:\n    \"\"\"Writes an index-like README.md.\n\n    Adds links to the file structure for easy browsing:\n    * [Greek (el)](./courses/courses_el.md)\n    * [English (en)](./courses/courses_en.md)\n    * [French (fr)](./courses/courses_fr.md)\n    etc.\n    \"\"\"\n\n    readme_path = out_folder / \"README.md\"\n    with readme_path.open(\"w\", encoding=\"utf-8\") as f:\n        for lang in langs:\n            f.write(f\"* [{lang}](./courses/courses_{lang}.md)\\n\")\n</code></pre>"},{"location":"api-reference/generated/commands/markdown/#commands.markdown.format_markdown","title":"format_markdown","text":"<pre><code>format_markdown(collection_list: list[Collection], include_views: bool) -&gt; str\n</code></pre> <p>Convert a list of Collection objects to markdown format.</p> Source code in <code>src/commands/markdown.py</code> <pre><code>def format_markdown(collection_list: list[Collection], include_views: bool) -&gt; str:\n    \"\"\"Convert a list of Collection objects to markdown format.\"\"\"\n    # Header\n    fixing_date_width = \"&amp;nbsp;\" * 6  # Ugly but works\n    columns = [\n        \"Status\",\n        \" \",\n        \"Title\",\n        \"Views\" if include_views else \"\",\n        \"Lessons\",\n        f\"Created{fixing_date_width}\",\n        f\"Updated{fixing_date_width}\",\n    ]\n    header = \"|\".join(columns)\n    header = header.replace(\"||\", \"|\")\n    n_columns = len(columns) if include_views else len(columns) - 1\n    separator = \"|\".join([\"-\"] * n_columns)\n\n    # Start building the markdown content\n    markdown_lines = []\n    markdown_lines.append(f\"|{header}|\\n\")\n    markdown_lines.append(f\"|{separator}|\\n\")\n\n    # Process each collection\n    for c in collection_list:\n        view_count = \"-\" if not c.views_count else c.views_count\n        is_shared = \"shared\" if c.is_shared else \"private\"\n        assert c.title is not None\n        sanitized_title = sanitize_title(c.title)\n        line_elements = [\n            is_shared,\n            c.level,\n            f\"[{sanitized_title}]({c.course_url})\",\n            view_count if include_views else \"\",\n            c.amount_lessons,\n            c.first_update,\n            c.last_update,\n        ]\n        line = \"|\" + \"|\".join(map(str, line_elements)) + \"\\n\"\n        line = line.replace(\"||\", \"|\")\n        markdown_lines.append(line)\n\n    return \"\".join(markdown_lines)\n</code></pre>"},{"location":"api-reference/generated/commands/markdown/#commands.markdown.get_collections","title":"get_collections  <code>async</code>","text":"<pre><code>get_collections(handler: LingqHandler, select_courses: str) -&gt; list[Collection]\n</code></pre> <p>A collection is just a course in the web lingo. Given a language code, returns a list of Collection objects. Those store the important information of the JSON to then make the markdown.</p> Source code in <code>src/commands/markdown.py</code> <pre><code>async def get_collections(handler: LingqHandler, select_courses: str) -&gt; list[Collection]:\n    \"\"\"A collection is just a course in the web lingo.\n    Given a language code, returns a list of Collection objects.\n    Those store the important information of the JSON to then make the markdown.\n    \"\"\"\n\n    _collections: list[CollectionItem] | list[SearchCollectionResult]\n    if select_courses == \"all\":\n        _collections = await handler.get_currently_studying_collections()\n    else:\n        _my_collections = await handler.get_my_collections()\n        _collections = _my_collections.results\n\n    collections_list: list[Collection] = []\n    n_collections = len(_collections)\n\n    tasks = [handler.get_collection_object_from_id(collection.id) for collection in _collections]\n    collections = await asyncio.gather(*tasks)\n    collections = [collection for collection in collections if collection is not None]\n\n    for idx, col in enumerate(collections, 1):\n        if col.last_update is None:\n            logger.info(f\"[{idx}/{n_collections}] SKIP {col.title} (last_update=None)\")\n        elif select_courses == \"shared\" and not col.is_shared:\n            logger.info(f\"[{idx}/{n_collections}] SKIP {col.title} (not shared)\")\n        else:\n            logger.success(f\"[{idx}/{n_collections}] {col.title}\")\n            collections_list.append(col)\n\n    return collections_list\n</code></pre>"},{"location":"api-reference/generated/commands/markdown/#commands.markdown.markdown","title":"markdown","text":"<pre><code>markdown(langs: list[str], select_courses: str, include_views: bool, out_folder: Path) -&gt; None\n</code></pre> <p>Generate markdown files for the given language codes.</p> <p>Parameters:</p> Name Type Description Default <code>langs</code> <code>list[str]</code> <p>List of language codes to process. If no language codes are given, use all languages.</p> required <code>select_courses</code> <code>str</code> <p>Determines which courses to include. - \"shared\" for only my imported and shared collections (ignore private) - \"mine\"   for only my imported collections - \"all\"    for everything in the \"Continue Studying\" shelf</p> required <code>include_views</code> <code>bool</code> <p>If True, includes the number of views in the markdown.</p> required <code>out_folder</code> <code>str</code> <p>The output folder where the markdown files will be saved.</p> required Source code in <code>src/commands/markdown.py</code> <pre><code>@timing\ndef markdown(\n    langs: list[str],\n    select_courses: str,\n    include_views: bool,\n    out_folder: Path,\n) -&gt; None:\n    \"\"\"Generate markdown files for the given language codes.\n\n    Args:\n        langs (list[str]): List of language codes to process.\n            If no language codes are given, use all languages.\n        select_courses (str): Determines which courses to include.\n            - \"shared\" for only my imported and shared collections (ignore private)\n            - \"mine\"   for only my imported collections\n            - \"all\"    for everything in the \"Continue Studying\" shelf\n        include_views (bool): If True, includes the number of views in the markdown.\n        out_folder (str): The output folder where the markdown files will be saved.\n    \"\"\"\n    if not langs:\n        langs = LingqHandler.get_user_langs()\n    asyncio.run(make_markdown_async(langs, select_courses, include_views, out_folder))\n</code></pre>"},{"location":"api-reference/generated/commands/merge/","title":"commands.merge","text":""},{"location":"api-reference/generated/commands/merge/#commands.merge","title":"merge","text":"<p>Merge one course into another.</p> <p>The old course, even if it remains without any lesson, will not be deleted.</p>"},{"location":"api-reference/generated/commands/patch/","title":"commands.patch","text":""},{"location":"api-reference/generated/commands/patch/#commands.patch","title":"patch","text":""},{"location":"api-reference/generated/commands/patch/#commands.patch.patch_audios","title":"patch_audios","text":"<pre><code>patch_audios(lang: str, course_id: int, audios_folder: Path) -&gt; None\n</code></pre> <p>Deals with overwriting of existing lessons / collections. The main usecase is to add audio to an already uploaded book where some editing has already be done, and we wouldn't want to upload the text again.</p> Source code in <code>src/commands/patch.py</code> <pre><code>@timing\ndef patch_audios(lang: str, course_id: int, audios_folder: Path) -&gt; None:\n    \"\"\"Deals with overwriting of existing lessons / collections.\n    The main usecase is to add audio to an already uploaded book where some\n    editing has already be done, and we wouldn't want to upload the text again.\n    \"\"\"\n    # The blank audios were found here: https://github.com/anars/blank-audio.\n    asyncio.run(patch_audios_async(lang, course_id, audios_folder))\n</code></pre>"},{"location":"api-reference/generated/commands/post/","title":"commands.post","text":""},{"location":"api-reference/generated/commands/post/#commands.post","title":"post","text":"<p>Bulk post utilities.</p> <p>Note: Posting only audio triggers whisper transcript generation on their servers.</p>"},{"location":"api-reference/generated/commands/post/#commands.post.check_extensions","title":"check_extensions","text":"<pre><code>check_extensions(paths: list[Path], supported: list[str]) -&gt; list[str]\n</code></pre> <p>Check if the extensions are supported.</p> <p>Ignores folders (i.e. folders inside the audio/text folder).</p> Source code in <code>src/commands/post.py</code> <pre><code>def check_extensions(paths: list[Path], supported: list[str]) -&gt; list[str]:\n    \"\"\"Check if the extensions are supported.\n\n    Ignores folders (i.e. folders inside the audio/text folder).\n    \"\"\"\n    extensions = list({path.suffix for path in paths})\n    for ext in extensions:\n        if ext != \"\" and ext not in supported:\n            raise UnsupportedExtensionError(ext)\n    return extensions\n</code></pre>"},{"location":"api-reference/generated/commands/post/#commands.post.post","title":"post","text":"<pre><code>post(lang: str, course_id: int, texts_folder: Path, audios_folder: Path | None = None, pairing_strategy: Strategy = 'exact') -&gt; None\n</code></pre> <p>Posts preprocessed split text and audio files to a specified course.</p> <p>The preprocessed split text (.txt or .srt) files should be in texts_folder, and the audio (.mp3 or .m4a) files should be in audios_folder.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>str</code> <p>The language code of the course.</p> required <code>course_id</code> <code>int</code> <p>The ID of the course. This is the last number in the course URL.</p> required <code>texts_folder</code> <code>Path</code> <p>The folder containing the preprocessed split text files.</p> required <code>audios_folder</code> <code>Path</code> <p>The folder containing the audio files. Set this to None to post only text. Defaults to None.</p> <code>None</code> <code>pairing_strategy</code> <code>str</code> <p>How to pair text and audio files. Options are: [\"zip\", \"zipsort\", \"exact\", \"fuzzy\"]</p> <code>'exact'</code> Source code in <code>src/commands/post.py</code> <pre><code>@timing\ndef post(\n    lang: str,\n    course_id: int,\n    texts_folder: Path,\n    audios_folder: Path | None = None,\n    pairing_strategy: Strategy = \"exact\",\n) -&gt; None:\n    \"\"\"Posts preprocessed split text and audio files to a specified course.\n\n    The preprocessed split text (.txt or .srt) files should be in texts_folder,\n    and the audio (.mp3 or .m4a) files should be in audios_folder.\n\n    Args:\n        lang (str): The language code of the course.\n        course_id (int): The ID of the course. This is the last number in the course URL.\n        texts_folder (Path): The folder containing the preprocessed split text files.\n        audios_folder (Path, optional): The folder containing the audio files.\n            Set this to None to post only text.\n            Defaults to None.\n        pairing_strategy (str, optional): How to pair text and audio files.\n            Options are: [\"zip\", \"zipsort\", \"exact\", \"fuzzy\"]\n    \"\"\"\n    asyncio.run(\n        post_async(\n            lang,\n            course_id,\n            texts_folder,\n            audios_folder,\n            pairing_strategy,\n        )\n    )\n</code></pre>"},{"location":"api-reference/generated/commands/post_yt_playlist/","title":"commands.post_yt_playlist","text":""},{"location":"api-reference/generated/commands/post_yt_playlist/#commands.post_yt_playlist","title":"post_yt_playlist","text":"<p>Use yt-dlp to scan a youtube playlist.</p> <ul> <li>Identifies if a lesson has Captions / Auto-generated subtitles / None</li> <li>Downloads the Auto-generated subtitles there are no captions</li> </ul> <p>With the recent LingQ changes, it only works with videos that have closed captions. Auto-generated subtitles or none of them will result in failure.</p>"},{"location":"api-reference/generated/commands/post_yt_playlist/#commands.post_yt_playlist.post_playlist_entry","title":"post_playlist_entry  <code>async</code>","text":"<pre><code>post_playlist_entry(handler: LingqHandler, course_id: int, entry: Any, idx: int, playlist_size: int, skip_no_cc: bool) -&gt; None\n</code></pre> <p>Request that only sends the url of the youtube video to LingQ. They do the subtitle generation when needed (that is, when there are no CC).</p> Source code in <code>src/commands/post_yt_playlist.py</code> <pre><code>async def post_playlist_entry(\n    handler: LingqHandler,\n    course_id: int,\n    entry: Any,\n    idx: int,\n    playlist_size: int,\n    skip_no_cc: bool,\n) -&gt; None:\n    \"\"\"Request that only sends the url of the youtube video to LingQ.\n    They do the subtitle generation when needed (that is, when there are no CC).\n    \"\"\"\n    title = entry[\"title\"]\n    lang = handler.lang\n    # logger.critical(entry.get(\"subtitles\", \"NSUB\"))\n    if not has_closed_captions(lang, entry):\n        logger.warning(f\"No closed captions: skipping {title}.\")\n        return\n\n    # assert len(title) &lt; 60  # Max allowed\n    # url = entry[\"url\"] # assumes \"extract_flat\": \"in_playlist\"\n    url = entry[\"original_url\" if skip_no_cc else \"url\"]\n    data: dict[str, str] = {\n        \"title\": title,\n        \"url\": url,\n        \"collection\": str(course_id),\n        \"save\": \"true\",\n    }\n\n    response = await handler.post_from_data_dict(data, raw=True)\n\n    if response.status == 201:\n        padded_idx = f\"{idx + 1}\".zfill(len(str(playlist_size)))\n        progress_msg = f\"[{padded_idx}/{playlist_size}]\"\n        logger.success(f\"{progress_msg} Uploaded: {title}\")\n</code></pre>"},{"location":"api-reference/generated/commands/post_yt_playlist/#commands.post_yt_playlist.post_playlist_fully_async","title":"post_playlist_fully_async  <code>async</code>","text":"<pre><code>post_playlist_fully_async(handler: LingqHandler, course_id: int, playlist: OldPlaylist, download_audio_info: bool) -&gt; None\n</code></pre> <p>Faster version if you don't care about the order in which the lessons are posted.</p> Source code in <code>src/commands/post_yt_playlist.py</code> <pre><code>async def post_playlist_fully_async(\n    handler: LingqHandler,\n    course_id: int,\n    playlist: OldPlaylist,\n    download_audio_info: bool,\n) -&gt; None:\n    \"\"\"Faster version if you don't care about the order in which the lessons are posted.\"\"\"\n    tasks = [\n        post_playlist_entry(handler, course_id, entry, idx, len(playlist), download_audio_info)\n        for idx, entry in enumerate(playlist)\n    ]\n    await asyncio.gather(*tasks)\n</code></pre>"},{"location":"api-reference/generated/commands/post_yt_playlist/#commands.post_yt_playlist.post_yt_playlist","title":"post_yt_playlist","text":"<pre><code>post_yt_playlist(lang: str, course_id: int, playlist_url: str, *, skip_uploaded: bool, skip_no_cc: bool = True) -&gt; None\n</code></pre> <p>Main function to download and upload videos from a YouTube playlist to LingQ.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>str</code> <p>The language code for the course.</p> required <code>course_id</code> <code>int</code> <p>The ID of the course to which videos will be uploaded.</p> required <code>playlist_url</code> <code>str</code> <p>The URL of the YouTube playlist or channel to download videos from.</p> required <code>skip_uploaded</code> <code>bool</code> <p>If True, skip videos already uploaded to the course. If False, overwrite existing ones.</p> required <code>skip_no_cc</code> <code>bool</code> <p>If True, skip videos without Closed Captions (CC). Requires download_audio_info to be true in order to get the necessary information.</p> <code>True</code> Source code in <code>src/commands/post_yt_playlist.py</code> <pre><code>@timing\ndef post_yt_playlist(\n    lang: str,\n    course_id: int,\n    playlist_url: str,\n    *,\n    skip_uploaded: bool,\n    skip_no_cc: bool = True,\n) -&gt; None:\n    \"\"\"Main function to download and upload videos from a YouTube playlist to LingQ.\n\n    Args:\n        lang (str): The language code for the course.\n        course_id (int): The ID of the course to which videos will be uploaded.\n        playlist_url (str): The URL of the YouTube playlist or channel to download videos from.\n        skip_uploaded (bool): If True, skip videos already uploaded to the course.\n            If False, overwrite existing ones.\n        skip_no_cc (bool): If True, skip videos without Closed Captions (CC).\n            Requires download_audio_info to be true in order to get the necessary information.\n    \"\"\"\n    asyncio.run(\n        post_yt_playlist_async(\n            lang,\n            course_id,\n            playlist_url,\n            skip_uploaded,\n            skip_no_cc,\n        )\n    )\n</code></pre>"},{"location":"api-reference/generated/commands/reindex/","title":"commands.reindex","text":""},{"location":"api-reference/generated/commands/reindex/#commands.reindex","title":"reindex","text":""},{"location":"api-reference/generated/commands/reindex/#commands.reindex.reindex","title":"reindex","text":"<pre><code>reindex(lang: str, course_id: int, *, dry_run: bool = False) -&gt; None\n</code></pre> <p>Reindex titles in a course.</p> Source code in <code>src/commands/reindex.py</code> <pre><code>def reindex(lang: str, course_id: int, *, dry_run: bool = False) -&gt; None:\n    \"\"\"Reindex titles in a course.\"\"\"\n    asyncio.run(reindex_async(lang, course_id, dry_run=dry_run))\n</code></pre>"},{"location":"api-reference/generated/commands/replace/","title":"commands.replace","text":""},{"location":"api-reference/generated/commands/replace/#commands.replace","title":"replace","text":""},{"location":"api-reference/generated/commands/replace/#commands.replace.replace","title":"replace","text":"<pre><code>replace(lang: str, course_id: int, replacements: dict[str, str]) -&gt; None\n</code></pre> <p>Replace text in a course.</p> Source code in <code>src/commands/replace.py</code> <pre><code>@timing\ndef replace(\n    lang: str,\n    course_id: int,\n    replacements: dict[str, str],\n) -&gt; None:\n    \"\"\"Replace text in a course.\"\"\"\n    asyncio.run(replace_async(lang, course_id, replacements))\n</code></pre>"},{"location":"api-reference/generated/commands/resplit/","title":"commands.resplit","text":""},{"location":"api-reference/generated/commands/resplit/#commands.resplit","title":"resplit","text":""},{"location":"api-reference/generated/commands/resplit/#commands.resplit.resplit_async","title":"resplit_async  <code>async</code>","text":"<pre><code>resplit_async(course_id: int) -&gt; None\n</code></pre> <p>Re-split an existing lesson in japanese with ichimoe.</p> <p>https://forum.lingq.com/t/refining-parsing-in-spaceless-languages-like-japanese-with-ai/179754</p> Source code in <code>src/commands/resplit.py</code> <pre><code>async def resplit_async(course_id: int) -&gt; None:\n    \"\"\"Re-split an existing lesson in japanese with ichimoe.\n\n    https://forum.lingq.com/t/refining-parsing-in-spaceless-languages-like-japanese-with-ai/179754\n    \"\"\"\n    async with LingqHandler(\"ja\") as handler:\n        lessons = await handler.get_collection_lessons_from_id(course_id)\n        if not lessons:\n            return\n        collection_title = lessons[0].collection_title\n        double_check(\n            f\"Resplitting words for course: {collection_title}\\n\"\n            \"WARN: There is currently a bug in lingq that modifies certains characters.\\n\"\n            \"      Be sure you have read:\\n\"\n            \"      https://forum.lingq.com/t/bug-japanese-re-split-modifies-sentence-quotes/412810\"\n        )\n        tasks = [handler.resplit_lesson(lesson.id, method=\"ichimoe\") for lesson in lessons]\n        await asyncio.gather(*tasks)\n</code></pre>"},{"location":"api-reference/generated/commands/show/","title":"commands.show","text":""},{"location":"api-reference/generated/commands/show/#commands.show","title":"show","text":""},{"location":"api-reference/generated/commands/show/#commands.show.show_my","title":"show_my","text":"<pre><code>show_my(lang: str, *, shared: bool, codes: bool, verbose: bool) -&gt; None\n</code></pre> <p>Show my collections in a given language.</p> Source code in <code>src/commands/show.py</code> <pre><code>def show_my(\n    lang: str,\n    *,\n    shared: bool,\n    codes: bool,\n    verbose: bool,\n) -&gt; None:\n    \"\"\"Show my collections in a given language.\"\"\"\n    titles = asyncio.run(get_my_collections_titles_async(lang, shared, codes, verbose))\n    for idx, title in enumerate(titles, 1):\n        print(f\"{idx:02}: {title}\")\n</code></pre>"},{"location":"api-reference/generated/commands/show/#commands.show.show_course","title":"show_course","text":"<pre><code>show_course(lang: str, course_id: int, *, shared: bool, codes: bool, verbose: bool) -&gt; None\n</code></pre> <p>Show lessons in a course.</p> Source code in <code>src/commands/show.py</code> <pre><code>def show_course(\n    lang: str,\n    course_id: int,\n    *,\n    shared: bool,\n    codes: bool,\n    verbose: bool,\n) -&gt; None:\n    \"\"\"Show lessons in a course.\"\"\"\n    titles = asyncio.run(get_course_titles_async(lang, course_id, shared, codes, verbose))\n    for idx, title in enumerate(titles, 1):\n        print(f\"{idx:02}: {title}\")\n</code></pre>"},{"location":"api-reference/generated/commands/show/#commands.show.show_status","title":"show_status","text":"<pre><code>show_status(lang: str) -&gt; None\n</code></pre> <p>Show pending and refused lessons in a language.</p> Source code in <code>src/commands/show.py</code> <pre><code>def show_status(lang: str) -&gt; None:\n    \"\"\"Show pending and refused lessons in a language.\"\"\"\n    titles = asyncio.run(get_status_titles_async(lang))\n    for idx, title in enumerate(titles, 1):\n        print(f\"{idx:02}: {title}\")\n</code></pre>"},{"location":"api-reference/generated/commands/sort_lessons/","title":"commands.sort_lessons","text":""},{"location":"api-reference/generated/commands/sort_lessons/#commands.sort_lessons","title":"sort_lessons","text":""},{"location":"api-reference/generated/commands/sort_lessons/#commands.sort_lessons.ST","title":"ST  <code>module-attribute</code>","text":"<pre><code>ST = tuple[float, ...]\n</code></pre> <p>Return type of a sorting function.</p>"},{"location":"api-reference/generated/commands/sort_lessons/#commands.sort_lessons.get_patch_requests_order_for_ids","title":"get_patch_requests_order_for_ids","text":"<pre><code>get_patch_requests_order_for_ids(lessons_ids: list[int], to_reorder: list[int]) -&gt; list[tuple[int, int]]\n</code></pre> <p>This is just a possible solution to the problem. Maybe there is a simpler approach that equally finds some requests needed to sort the lessons.</p> Source code in <code>src/commands/sort_lessons.py</code> <pre><code>def get_patch_requests_order_for_ids(\n    lessons_ids: list[int], to_reorder: list[int]\n) -&gt; list[tuple[int, int]]:\n    \"\"\"This is just a possible solution to the problem. Maybe there is a simpler\n    approach that equally finds some requests needed to sort the lessons.\"\"\"\n    fix_members = [0] + [elt for elt in lessons_ids if elt not in to_reorder]\n    requests_with_ids: list[tuple[int, int]] = []\n\n    for lesson_id in to_reorder:\n        first_bigger_fix_member_idx = len(fix_members)\n        for nidx, member in enumerate(fix_members):\n            if member &gt; lesson_id:\n                first_bigger_fix_member_idx = nidx\n                break\n        first_bigger_fix_member_idx -= 1\n\n        should_go_after_this = fix_members[first_bigger_fix_member_idx]\n        fix_members.insert(first_bigger_fix_member_idx + 1, lesson_id)\n        if should_go_after_this in lessons_ids:\n            should_go = lessons_ids.index(should_go_after_this) + 1\n        else:\n            should_go = 0\n\n        lesson_idx = lessons_ids.index(lesson_id)\n        lessons_ids.pop(lesson_idx)\n        offset = 1 if should_go &gt; lesson_idx else 0\n        lessons_ids.insert(should_go - offset, lesson_id)\n        requests_with_ids.append((lesson_id, should_go - offset + 1))\n\n    return requests_with_ids\n</code></pre>"},{"location":"api-reference/generated/commands/sort_lessons/#commands.sort_lessons.get_patch_requests_order","title":"get_patch_requests_order","text":"<pre><code>get_patch_requests_order(lessons: list[CollectionLessonResult]) -&gt; list[tuple[CollectionLessonResult, int]]\n</code></pre> <p>Faster (and way more complicated) version to minimize the number of requests. Uses a longest increasing subsequence to identify the lessons that should not be moved around, then computes some possible requests that sort the lessons.</p> Source code in <code>src/commands/sort_lessons.py</code> <pre><code>def get_patch_requests_order(\n    lessons: list[CollectionLessonResult],\n) -&gt; list[tuple[CollectionLessonResult, int]]:\n    \"\"\"Faster (and way more complicated) version to minimize the number of requests.\n    Uses a longest increasing subsequence to identify the lessons that should\n    not be moved around, then computes some possible requests that sort the lessons.\"\"\"\n    sorted_lessons = sorted(lessons, key=sorting_function)\n    sorted_idxs: dict[str, int] = {}\n    for idx, sorted_lesson in enumerate(sorted_lessons, 1):\n        sorted_idxs[sorted_lesson.title] = idx\n    lessons_ids_mapping: dict[int, CollectionLessonResult] = {\n        sorted_idxs[lesson.title]: lesson for lesson in lessons\n    }\n    lessons_ids: list[int] = list(lessons_ids_mapping.keys())\n\n    lis = longest_increasing_subsequence(lessons_ids)\n    to_reorder = sorted(lesson_id for lesson_id in lessons_ids if lesson_id not in lis)\n    logger.debug(f\"We need to reorder '{len(to_reorder)}' lessons.\")  # Optimal\n\n    requests_with_ids = get_patch_requests_order_for_ids(lessons_ids, to_reorder)\n    requests = [(lessons_ids_mapping[lesson_id], pos) for lesson_id, pos in requests_with_ids]\n\n    return requests\n</code></pre>"},{"location":"api-reference/generated/commands/stats/","title":"commands.stats","text":""},{"location":"api-reference/generated/commands/stats/#commands.stats","title":"stats","text":""},{"location":"api-reference/generated/commands/stats/#commands.stats.stats","title":"stats","text":"<pre><code>stats(lang: str) -&gt; None\n</code></pre> <p>Show some simple stats.</p> Source code in <code>src/commands/stats.py</code> <pre><code>def stats(lang: str) -&gt; None:\n    \"\"\"Show some simple stats.\"\"\"\n    asyncio.run(stats_async(lang))\n</code></pre>"},{"location":"api-reference/generated/commands/yomitan/","title":"commands.yomitan","text":""},{"location":"api-reference/generated/commands/yomitan/#commands.yomitan","title":"yomitan","text":"<p>Instructions.</p> <p>What to do once you managed to create a yomitan dictionary:</p> <p>(1) Install yomitan if you haven't: https://github.com/yomidevs/yomitan (2) Click the settings cog. (3) Preferably create a new profile:     - Click \"Configure profiles\", then add.     - Choose a meaningful name like \"lingq-your-language\". (4) Set the profile as \"Default\" and \"Editing\" if they are not already. (5) Set the language in \"General\". (6) Click \"Configure installed and enabled dictionaries\".     - Click import     - Drag the zipped dictionary (do not unzip it).     - Select it to be used. (7) That is all. If you want to further customize Yomitan check their guides.</p>"},{"location":"api-reference/generated/commands/yomitan/#commands.yomitan.get_dictionary_index","title":"get_dictionary_index","text":"<pre><code>get_dictionary_index(lang: str) -&gt; YomitanIndex\n</code></pre> <p>Make a yomitan dictionary index.</p> <p>Roughly based on the index from the Kaikki-to-yomitan downloads page: https://github.com/yomidevs/kaikki-to-yomitan/blob/master/downloads.md</p> Source code in <code>src/commands/yomitan.py</code> <pre><code>def get_dictionary_index(lang: str) -&gt; YomitanIndex:\n    \"\"\"Make a yomitan dictionary index.\n\n    Roughly based on the index from the Kaikki-to-yomitan downloads page:\n    https://github.com/yomidevs/kaikki-to-yomitan/blob/master/downloads.md\n    \"\"\"\n    return {\n        \"format\": 3,\n        \"revision\": datetime.now().strftime(\"%Y.%m.%d\"),\n        \"sequenced\": True,\n        # Change this if necessary\n        \"author\": \"https://github.com/daxida\",\n        \"url\": \"https://github.com/daxida/lingq\",\n        \"description\": \"Dictionary generated from LingQ data.\",\n        # Change these two if necessary\n        \"sourceLanguage\": lang,\n        \"targetLanguage\": \"en\",\n        \"title\": f\"lingq-{lang}\",\n    }\n</code></pre>"},{"location":"api-reference/generated/commands/yomitan/#commands.yomitan.card_to_yomitan_entry","title":"card_to_yomitan_entry","text":"<pre><code>card_to_yomitan_entry(card: Card) -&gt; YomitanEntry\n</code></pre> <p>Convert the Card model to a dictionary entry.</p> <p>Discussion about the structure: https://github.com/themoeway/kaikki-to-yomitan/issues/55</p> <p>Examples used as references: https://github.com/themoeway/kaikki-to-yomitan/blob/433636cf74cb530a241f9c4c3842a2c11dd3b084/data/test/dict/fr/en/term_bank_1.json#L1 https://github.com/themoeway/jmdict-yomitan?tab=readme-ov-file#jmdict-for-yomitan-1</p> Source code in <code>src/commands/yomitan.py</code> <pre><code>def card_to_yomitan_entry(card: Card) -&gt; YomitanEntry:\n    \"\"\"Convert the Card model to a dictionary entry.\n\n    Discussion about the structure:\n    https://github.com/themoeway/kaikki-to-yomitan/issues/55\n\n    Examples used as references:\n    https://github.com/themoeway/kaikki-to-yomitan/blob/433636cf74cb530a241f9c4c3842a2c11dd3b084/data/test/dict/fr/en/term_bank_1.json#L1\n    https://github.com/themoeway/jmdict-yomitan?tab=readme-ov-file#jmdict-for-yomitan-1\n    \"\"\"\n\n    glossary_content = []\n    for hint in card.hints:\n        fmt_hint = {\"content\": hint.text, \"tag\": \"li\"}\n        glossary_content.append(fmt_hint)\n    glossary = {\"content\": glossary_content, \"data\": {\"content\": \"glossary\"}, \"tag\": \"ul\"}\n\n    if card.notes:\n        notes_content = [{\"content\": card.notes, \"tag\": \"li\"}]\n        notes = {\"content\": notes_content, \"data\": {\"content\": \"notes\"}, \"tag\": \"ul\"}\n    else:\n        notes = None\n\n    example_content = [{\"content\": card.fragment, \"tag\": \"li\"}]\n    example = {\n        \"content\": example_content,\n        \"style\": {\"fontStyle\": \"italic\"},\n        \"data\": {\"content\": \"example\"},\n        \"tag\": \"ul\",\n    }\n\n    # Actually only notes can be None\n    definitions_contents = [x for x in (glossary, example, notes) if x is not None]\n    definitions = [{\"type\": \"structured-content\", \"content\": definitions_contents}]\n\n    # The keys are only for documentation. It is immediately converted to a list.\n    _entry = {\n        \"term\": card.term,\n        \"readings\": \"\",  # card.transliteration.get(\"latin\", \"\"),\n        # Abbreviations expanded in tag_bank_1.json\n        # (LINGQ) A grammar tag is a tag that appear both in tags and g_tags\n        \"definition_tags\": \" \".join(card.tags),  # space separated\n        \"rule_identifiers\": \"\",\n        \"score\": 0,\n        # Can do this for a minimal version: [hint.text for hint in card.hints]\n        \"definitions_list\": definitions,\n        \"sequence_number\": 0,  # ignore\n        \"term_tags\": \"\",\n    }\n    entry: YomitanEntry = list(_entry.values())\n    return entry\n</code></pre>"},{"location":"api-reference/generated/commands/yomitan/#commands.yomitan.card_to_yomitan_entry_simple","title":"card_to_yomitan_entry_simple","text":"<pre><code>card_to_yomitan_entry_simple(card: Card) -&gt; YomitanEntry\n</code></pre> <p>Minimal yomitan entry. Contains only the terms, tags and hints with no format.</p> Source code in <code>src/commands/yomitan.py</code> <pre><code>def card_to_yomitan_entry_simple(card: Card) -&gt; YomitanEntry:\n    \"\"\"Minimal yomitan entry.\n    Contains only the terms, tags and hints with no format.\n    \"\"\"\n    entry: YomitanEntry = [\n        card.term,\n        \"\",\n        \" \".join(card.tags),\n        \"\",\n        0,\n        [hint.text for hint in card.hints],\n        0,\n        \"\",\n    ]\n    return entry\n</code></pre>"},{"location":"api-reference/generated/commands/yomitan/#commands.yomitan.yomitan_for_language","title":"yomitan_for_language","text":"<pre><code>yomitan_for_language(dump_path: Path) -&gt; YomitanDict\n</code></pre> <p>Read and convert the JSON obtained from LingQ.</p> Source code in <code>src/commands/yomitan.py</code> <pre><code>def yomitan_for_language(dump_path: Path) -&gt; YomitanDict:\n    \"\"\"Read and convert the JSON obtained from LingQ.\"\"\"\n    # NOTE: split the dict into manageable jsons?\n    # TODO: make a different entry per hint?\n    #       That is: single card -&gt; list[YomitanEntry]\n\n    # Look for the dump\n    lingq_json_path = dump_path / \"lingqs.json\"\n    if not lingq_json_path.exists():\n        logger.error(f\"Could not find the dump at {lingq_json_path}. Exiting.\")\n        sys.exit(1)\n\n    # Load the dump\n    with lingq_json_path.open(\"r\", encoding=\"utf-8\") as f:\n        words = json.load(f)\n        words = [Card.model_validate(word) for word in words]\n\n    # Convert to Yomitan\n    yomitan_dict: YomitanDict = []\n    for card in words:\n        entry = card_to_yomitan_entry_simple(card)\n        yomitan_dict.append(entry)\n\n    return yomitan_dict\n</code></pre>"},{"location":"api-reference/generated/commands/yomitan/#commands.yomitan.write_yomitan_dict","title":"write_yomitan_dict","text":"<pre><code>write_yomitan_dict(lang: str, out_path: Path, yomitan_dict: YomitanDict) -&gt; None\n</code></pre> <p>Write the zipped yomitan dict.</p> Source code in <code>src/commands/yomitan.py</code> <pre><code>def write_yomitan_dict(lang: str, out_path: Path, yomitan_dict: YomitanDict) -&gt; None:\n    \"\"\"Write the zipped yomitan dict.\"\"\"\n    zip_buffer = io.BytesIO()\n    with zipfile.ZipFile(zip_buffer, \"w\", zipfile.ZIP_DEFLATED, allowZip64=True) as zipf:\n        index = get_dictionary_index(lang)\n        zipf.writestr(\"index.json\", json.dumps(index, indent=2, ensure_ascii=False))\n        # I'm not sure what is the correct size to split\n        zipf.writestr(\"term_bank_1.json\", json.dumps(yomitan_dict, indent=2, ensure_ascii=False))\n\n    with out_path.open(\"wb\") as f:\n        f.write(zip_buffer.getvalue())\n</code></pre>"},{"location":"api-reference/generated/commands/yomitan/#commands.yomitan.yomitan","title":"yomitan","text":"<pre><code>yomitan(langs: list[str], opath: Path) -&gt; None\n</code></pre> <p>Make a Yomitan dictionary from a LingQ JSON dump generated through get_words.</p> <p>If no language codes are given, use all languages.</p> Source code in <code>src/commands/yomitan.py</code> <pre><code>def yomitan(langs: list[str], opath: Path) -&gt; None:\n    \"\"\"Make a Yomitan dictionary from a LingQ JSON dump generated through get_words.\n\n    If no language codes are given, use all languages.\n    \"\"\"\n    if not langs:\n        langs = LingqHandler.get_user_langs()\n\n    for lang in langs:\n        dump_path = opath / lang\n        yomitan_dict = yomitan_for_language(dump_path)\n        out_path = dump_path / f\"lingqs-{lang}.zip\"\n        write_yomitan_dict(lang, out_path, yomitan_dict)\n        logger.success(f\"Finished dictionary for {lang} at: {out_path}\")\n</code></pre>"},{"location":"api-reference/generated/models/cards/","title":"models.cards","text":""},{"location":"api-reference/generated/models/cards/#models.cards","title":"cards","text":""},{"location":"api-reference/generated/models/collection/","title":"models.collection","text":""},{"location":"api-reference/generated/models/collection/#models.collection","title":"collection","text":""},{"location":"api-reference/generated/models/collection/#models.collection.Collection","title":"Collection  <code>dataclass</code>","text":"<p>This collection object uses LingQ's API V2.</p> Source code in <code>src/models/collection.py</code> <pre><code>@dataclass\nclass Collection:\n    \"\"\"This collection object uses LingQ's API V2.\"\"\"\n\n    # fmt: off\n    _id:            int = 0\n    title:          str | None = None\n    lang:           str | None = None\n    course_url:     str | None = None\n    level:          str = \"-\"\n    has_audio:      bool = False\n    is_shared:      bool = False\n    first_update:   str | None = None\n    last_update:    str | None = None\n    amount_lessons: int = 0\n    views_count:    int = 0\n    # fmt: on\n\n    def add_data(self, lang: str, collection_v2: Any) -&gt; None:\n        \"\"\"Transfer the data from the JSON to the Collection object.\n        Can't use V3 because of the lack of pubDate...\n        \"\"\"\n        self.lang = lang\n        self._id = collection_v2[\"pk\"]  # it's pk in V2 and id in V3\n        self.title = collection_v2[\"title\"]\n        editor_url = get_editor_url(lang, int(self._id), \"course\")\n        self.course_url = editor_url\n\n        lessons = collection_v2[\"lessons\"]\n        if not lessons:\n            logger.warning(f\"No lessons found for '{self.title}' at {editor_url}\")\n            return\n\n        self.level = TO_EUROPEAN.get(collection_v2[\"level\"], collection_v2[\"level\"]) or \"-\"\n        self.has_audio = lessons[0][\"audio\"] is not None\n        self.last_update = lessons[0][\"pubDate\"]\n        self.first_update = lessons[0][\"pubDate\"]\n\n        for lesson in lessons:\n            # The collection has audio if at least one lesson has audio:\n            self.has_audio = self.has_audio or (lesson[\"audio\"] is not None)\n\n            # The collection is shated if at least one lesson is shared:\n            # NOTE: D for private, P for public\n            self.is_shared = self.is_shared or (lesson[\"status\"] == \"P\")\n            # print(lesson[\"status\"] == \"P\")\n\n            # Track the first and last updates:\n            assert self.first_update is not None\n            assert self.last_update is not None\n            cur_update = dt.strptime(lesson[\"pubDate\"], \"%Y-%m-%d\")\n            if dt.strptime(self.first_update, \"%Y-%m-%d\") &gt; cur_update:\n                self.first_update = lesson[\"pubDate\"]\n            if dt.strptime(self.last_update, \"%Y-%m-%d\") &lt; cur_update:\n                self.last_update = lesson[\"pubDate\"]\n\n            # The view count is the total sum of the viewsCount of the lessons\n            self.views_count += lesson[\"viewsCount\"]\n\n        # We remove our own view from the count (assuming we read everything).\n        self.amount_lessons = len(lessons)\n        self.views_count -= self.amount_lessons\n</code></pre>"},{"location":"api-reference/generated/models/collection/#models.collection.Collection.add_data","title":"add_data","text":"<pre><code>add_data(lang: str, collection_v2: Any) -&gt; None\n</code></pre> <p>Transfer the data from the JSON to the Collection object. Can't use V3 because of the lack of pubDate...</p> Source code in <code>src/models/collection.py</code> <pre><code>def add_data(self, lang: str, collection_v2: Any) -&gt; None:\n    \"\"\"Transfer the data from the JSON to the Collection object.\n    Can't use V3 because of the lack of pubDate...\n    \"\"\"\n    self.lang = lang\n    self._id = collection_v2[\"pk\"]  # it's pk in V2 and id in V3\n    self.title = collection_v2[\"title\"]\n    editor_url = get_editor_url(lang, int(self._id), \"course\")\n    self.course_url = editor_url\n\n    lessons = collection_v2[\"lessons\"]\n    if not lessons:\n        logger.warning(f\"No lessons found for '{self.title}' at {editor_url}\")\n        return\n\n    self.level = TO_EUROPEAN.get(collection_v2[\"level\"], collection_v2[\"level\"]) or \"-\"\n    self.has_audio = lessons[0][\"audio\"] is not None\n    self.last_update = lessons[0][\"pubDate\"]\n    self.first_update = lessons[0][\"pubDate\"]\n\n    for lesson in lessons:\n        # The collection has audio if at least one lesson has audio:\n        self.has_audio = self.has_audio or (lesson[\"audio\"] is not None)\n\n        # The collection is shated if at least one lesson is shared:\n        # NOTE: D for private, P for public\n        self.is_shared = self.is_shared or (lesson[\"status\"] == \"P\")\n        # print(lesson[\"status\"] == \"P\")\n\n        # Track the first and last updates:\n        assert self.first_update is not None\n        assert self.last_update is not None\n        cur_update = dt.strptime(lesson[\"pubDate\"], \"%Y-%m-%d\")\n        if dt.strptime(self.first_update, \"%Y-%m-%d\") &gt; cur_update:\n            self.first_update = lesson[\"pubDate\"]\n        if dt.strptime(self.last_update, \"%Y-%m-%d\") &lt; cur_update:\n            self.last_update = lesson[\"pubDate\"]\n\n        # The view count is the total sum of the viewsCount of the lessons\n        self.views_count += lesson[\"viewsCount\"]\n\n    # We remove our own view from the count (assuming we read everything).\n    self.amount_lessons = len(lessons)\n    self.views_count -= self.amount_lessons\n</code></pre>"},{"location":"api-reference/generated/models/collection_v3/","title":"models.collection_v3","text":""},{"location":"api-reference/generated/models/collection_v3/#models.collection_v3","title":"collection_v3","text":""},{"location":"api-reference/generated/models/collection_v3/#models.collection_v3.CollectionV3","title":"CollectionV3","text":"<p>               Bases: <code>BaseModel</code></p> <p>Collection model for API v3.</p> <p>https://www.lingq.com/api/v3/el/collections/1765504/</p> Source code in <code>src/models/collection_v3.py</code> <pre><code>class CollectionV3(BaseModel):\n    \"\"\"Collection model for API v3.\n\n    https://www.lingq.com/api/v3/el/collections/1765504/\n    \"\"\"\n\n    model_config = ConfigDict(\n        alias_generator=to_camel,\n        populate_by_name=True,\n    )\n\n    id: int\n    type: str\n    title: str\n    status: str\n    source: CollectionSource | None\n    is_taken: bool | None\n    image_url: HttpUrl\n    audio_pending: bool\n    original_image_url: HttpUrl | None\n    provider_image_url: HttpUrl | None\n    shared_by_image_url: HttpUrl\n    provider_id: int | None\n    provider_name: str | None\n    shared_by_id: int\n    shared_by_name: str\n    shared_by_role: str | None\n    description: str\n    is_featured: bool | None\n    is_locked: bool | None\n    lessons_count: int\n    new_words_count: int\n    difficulty: float\n    roses_count: int\n    views_count: int\n    duration: int\n    progress: str | None\n    # metadata: dict | None\n    folders: list[int]\n    accent: str | None\n    level: str | None\n    price: int\n    date: str\n    tags: list[str]\n    url: str\n</code></pre>"},{"location":"api-reference/generated/models/counter/","title":"models.counter","text":""},{"location":"api-reference/generated/models/counter/#models.counter","title":"counter","text":""},{"location":"api-reference/generated/models/hint/","title":"models.hint","text":""},{"location":"api-reference/generated/models/hint/#models.hint","title":"hint","text":""},{"location":"api-reference/generated/models/lesson_v3/","title":"models.lesson_v3","text":""},{"location":"api-reference/generated/models/lesson_v3/#models.lesson_v3","title":"lesson_v3","text":"<p>Lesson model for API v3.</p> <p>https://www.lingq.com/api/v3/el/lessons/31145860/</p>"},{"location":"api-reference/generated/models/lesson_v3/#models.lesson_v3.format_timestamp","title":"format_timestamp","text":"<pre><code>format_timestamp(seconds: float) -&gt; str\n</code></pre> <p>Format seconds to VTT format (HH:MM:SS.mmm).</p> Source code in <code>src/models/lesson_v3.py</code> <pre><code>def format_timestamp(seconds: float) -&gt; str:\n    \"\"\"Format seconds to VTT format (HH:MM:SS.mmm).\"\"\"\n    hours = int(seconds // 3600)\n    minutes = int((seconds % 3600) // 60)\n    secs = int(seconds % 60)\n    millis = int((seconds * 1000) % 1000)\n    return f\"{hours:02}:{minutes:02}:{secs:02}.{millis:03}\"\n</code></pre>"},{"location":"api-reference/generated/models/my_collections/","title":"models.my_collections","text":""},{"location":"api-reference/generated/models/my_collections/#models.my_collections","title":"my_collections","text":""},{"location":"api-reference/generated/models/readings/","title":"models.readings","text":""},{"location":"api-reference/generated/models/readings/#models.readings","title":"readings","text":""},{"location":"api-reference/generated/models/transliteration/","title":"models.transliteration","text":""},{"location":"api-reference/generated/models/transliteration/#models.transliteration","title":"transliteration","text":""},{"location":"tutorials/managing/","title":"Managing Courses","text":"<p>This tutorial covers course management operations like sorting, merging, updating, and organizing lessons.</p>"},{"location":"tutorials/managing/#sorting-lessons","title":"Sorting Lessons","text":""},{"location":"tutorials/managing/#why-sort","title":"Why Sort?","text":"<p>Lessons can become unordered when: - Uploading in multiple batches - Manual reordering on the website - Importing from different sources</p>"},{"location":"tutorials/managing/#available-sort-keys","title":"Available Sort Keys","text":""},{"location":"tutorials/managing/#natural-sort","title":"Natural Sort","text":"<p>Best for most cases with numbers:</p> <pre><code>lingq sort en 129129 --sort-key natural\n</code></pre> <p>Handles: - <code>Lesson 1</code>, <code>Lesson 2</code>, ..., <code>Lesson 10</code>, <code>Lesson 11</code> - <code>Chapter1</code>, <code>Chapter2</code>, ..., <code>Chapter10</code> - Mixed text and numbers</p>"},{"location":"tutorials/managing/#greek-sort","title":"Greek Sort","text":"<p>For Greek alphabet ordering:</p> <pre><code>lingq sort el 129129 --sort-key greek\n</code></pre> <p>Orders by: - Alpha (\u0391), Beta (\u0392), Gamma (\u0393), Delta (\u0394), etc. - Handles both uppercase and lowercase - Accent-insensitive</p>"},{"location":"tutorials/managing/#roman-numeral-sort","title":"Roman Numeral Sort","text":"<p>For Roman numerals:</p> <pre><code>lingq sort la 129129 --sort-key roman\n</code></pre> <p>Handles: - I, II, III, IV, V, etc. - Mixed with text: <code>Chapter I</code>, <code>Chapter II</code></p>"},{"location":"tutorials/managing/#versioned-sort","title":"Versioned Sort","text":"<p>For version-style numbering:</p> <pre><code>lingq sort en 129129 --sort-key versioned\n</code></pre> <p>Handles: - <code>1.1</code>, <code>1.2</code>, <code>1.10</code>, <code>2.1</code> - <code>Chapter 1.1</code>, <code>Chapter 1.2</code></p>"},{"location":"tutorials/managing/#reindexing-lessons","title":"Reindexing Lessons","text":""},{"location":"tutorials/managing/#adding-numbers-to-titles","title":"Adding Numbers to Titles","text":"<p>Automatically number lessons:</p> <pre><code>lingq reindex en 129129\n</code></pre> <p>Before: <pre><code>Introduction\nFirst Chapter\nSecond Chapter\nConclusion\n</code></pre></p> <p>After: <pre><code>1. Introduction\n2. First Chapter\n3. Second Chapter\n4. Conclusion\n</code></pre></p>"},{"location":"tutorials/managing/#use-cases","title":"Use Cases","text":"<ul> <li>Adding consistent numbering to imported content</li> <li>Fixing gaps after deleting lessons</li> <li>Preparing courses for export</li> </ul>"},{"location":"tutorials/managing/#merging-courses","title":"Merging Courses","text":""},{"location":"tutorials/managing/#basic-merge","title":"Basic Merge","text":"<p>Combine multiple courses into one:</p> <pre><code>lingq merge en 129129 129130 129131 -t \"Complete Series\"\n</code></pre>"},{"location":"tutorials/managing/#what-happens","title":"What Happens","text":"<ol> <li>Creates a new course titled \"Complete Series\"</li> <li>Copies all lessons from source courses in order</li> <li>Preserves audio and text</li> <li>Original courses remain unchanged</li> </ol>"},{"location":"tutorials/managing/#use-cases_1","title":"Use Cases","text":"<ul> <li>Combining a book series</li> <li>Consolidating related content</li> <li>Creating compilation courses</li> </ul>"},{"location":"tutorials/managing/#workflow-example","title":"Workflow Example","text":"<pre><code># Step 1: Merge courses\nlingq merge ja 129129 129130 129131 -t \"Complete Textbook\"\n\n# Step 2: Get the new course ID from output\n# (e.g., \"Created collection ID: 129999\")\n\n# Step 3: Sort the merged content\nlingq sort ja 129999 --sort-key natural\n\n# Step 4: Reindex with numbers\nlingq reindex ja 129999\n</code></pre>"},{"location":"tutorials/managing/#updating-audio","title":"Updating Audio","text":""},{"location":"tutorials/managing/#replace-existing-audio","title":"Replace Existing Audio","text":"<p>Update audio files in a course:</p> <pre><code>lingq patch audios en 129129 \"new-audio/\" --pairing-strategy fuzzy\n</code></pre>"},{"location":"tutorials/managing/#when-to-update","title":"When to Update","text":"<ul> <li>Improved audio quality available</li> <li>Fixed pronunciation errors</li> <li>Better recording conditions</li> <li>Different speaker/voice</li> </ul>"},{"location":"tutorials/managing/#file-preparation","title":"File Preparation","text":"<pre><code>new-audio/\n\u251c\u2500\u2500 Lesson 1.mp3  (better quality)\n\u251c\u2500\u2500 Lesson 2.mp3  (better quality)\n\u2514\u2500\u2500 Lesson 3.mp3  (better quality)\n</code></pre>"},{"location":"tutorials/managing/#after-patching","title":"After Patching","text":"<p>Regenerate timestamps if needed:</p> <pre><code>lingq timestamp en 129129\n</code></pre>"},{"location":"tutorials/managing/#deleting-lessons","title":"Deleting Lessons","text":""},{"location":"tutorials/managing/#individual-lessons","title":"Individual Lessons","text":"<p>Currently requires direct API access. Alternative: use LingQ website.</p>"},{"location":"tutorials/managing/#entire-course","title":"Entire Course","text":"<p>Use the website or contact support for bulk deletion.</p>"},{"location":"tutorials/managing/#text-replacement","title":"Text Replacement","text":""},{"location":"tutorials/managing/#find-and-replace","title":"Find and Replace","text":"<p>Replace text across all lessons in a course:</p> <pre><code>lingq replace en 129129 \"old text\" \"new text\"\n</code></pre>"},{"location":"tutorials/managing/#regex-patterns","title":"Regex Patterns","text":"<p>Use regex for complex replacements:</p> <pre><code># Remove text in brackets\nlingq replace en 129129 \"\\[.*?\\]\" \"\"\n\n# Fix numbering format\nlingq replace en 129129 \"Chapter (\\d+)\" \"Ch. $1\"\n\n# Clean up spaces\nlingq replace en 129129 \"\\s+\" \" \"\n</code></pre>"},{"location":"tutorials/managing/#common-use-cases","title":"Common Use Cases","text":"<p>Remove annotations: <pre><code>lingq replace ja 129129 \"\u3010.*?\u3011\" \"\"\n</code></pre></p> <p>Fix quotation marks: <pre><code>lingq replace en 129129 '\"' '\"'\nlingq replace en 129129 '\"' '\"'\n</code></pre></p> <p>Update formatting: <pre><code>lingq replace de 129129 \"(\\d+)\\.\" \"$1)\"\n</code></pre></p>"},{"location":"tutorials/managing/#resplitting-japanese-only","title":"Resplitting (Japanese Only)","text":""},{"location":"tutorials/managing/#what-is-resplitting","title":"What is Resplitting?","text":"<p>Updates word segmentation in Japanese lessons:</p> <pre><code>lingq resplit ja 129129\n</code></pre>"},{"location":"tutorials/managing/#when-to-use","title":"When to Use","text":"<ul> <li>After LingQ updates tokenization</li> <li>Improving word boundaries</li> <li>Better LingQ creation accuracy</li> </ul>"},{"location":"tutorials/managing/#what-it-does","title":"What It Does","text":"<ol> <li>Re-tokenizes all text in the course</li> <li>Updates word boundaries</li> <li>Preserves your existing LingQs</li> <li>Updates lesson metadata</li> </ol> <p>Japanese Only</p> <p>This feature only works with Japanese (<code>ja</code>) language code.</p>"},{"location":"tutorials/managing/#generating-timestamps","title":"Generating Timestamps","text":""},{"location":"tutorials/managing/#basic-usage","title":"Basic Usage","text":"<p>Create timestamps for lessons with audio:</p> <pre><code>lingq timestamp de 129129\n</code></pre>"},{"location":"tutorials/managing/#how-it-works","title":"How It Works","text":"<ol> <li>Calculates proportional timestamps based on:</li> <li>Audio duration</li> <li>Text length</li> <li>Word count</li> <li>Assigns timestamps to sentences</li> <li>Skips lessons that already have timestamps</li> </ol>"},{"location":"tutorials/managing/#specific-lessons","title":"Specific Lessons","text":"<p>Process only certain lessons:</p> <pre><code>lingq timestamp en 129129 --lesson-ids 12345678 12345679 12345680\n</code></pre>"},{"location":"tutorials/managing/#best-practices","title":"Best Practices","text":"<ul> <li>Run after uploading new lessons with audio</li> <li>Re-run if you update audio files</li> <li>Check first few lessons to verify accuracy</li> </ul>"},{"location":"tutorials/managing/#course-statistics","title":"Course Statistics","text":""},{"location":"tutorials/managing/#view-statistics","title":"View Statistics","text":"<p>Check course progress:</p> <pre><code>lingq stats ja\n</code></pre> <p>Shows: - Known words - Reading hours - Lessons completed - LingQs created - And more</p>"},{"location":"tutorials/managing/#library-overview","title":"Library Overview","text":"<p>Generate CSV of all courses:</p> <pre><code>lingq overview\n</code></pre> <p>Output includes: - Course titles and IDs - Lesson counts - Word counts - Status information</p>"},{"location":"tutorials/managing/#organizing-workflow","title":"Organizing Workflow","text":""},{"location":"tutorials/managing/#recommended-process","title":"Recommended Process","text":"<ol> <li> <p>Initial Upload <pre><code>lingq post ja -c \"My Course\" \"texts/\" -a \"audios/\" --pairing-strategy zip\n</code></pre></p> </li> <li> <p>Generate Timestamps <pre><code>lingq timestamp ja 129999\n</code></pre></p> </li> <li> <p>Sort Lessons <pre><code>lingq sort ja 129999 --sort-key natural\n</code></pre></p> </li> <li> <p>Add Numbering <pre><code>lingq reindex ja 129999\n</code></pre></p> </li> <li> <p>Verify</p> </li> <li>Check on LingQ website</li> <li>Test first lesson</li> <li>Confirm audio syncs correctly</li> </ol>"},{"location":"tutorials/managing/#best-practices_1","title":"Best Practices","text":""},{"location":"tutorials/managing/#before-making-changes","title":"Before Making Changes","text":"<p>Safety First</p> <ol> <li>Test on a copy if possible</li> <li>Document course IDs before merging</li> <li>Backup exports using <code>lingq get lessons</code></li> <li>Start small - test with one lesson</li> </ol>"},{"location":"tutorials/managing/#regular-maintenance","title":"Regular Maintenance","text":"<ul> <li>Sort lessons after new uploads</li> <li>Update timestamps when changing audio</li> <li>Regenerate documentation periodically</li> <li>Export vocabulary regularly</li> </ul>"},{"location":"tutorials/managing/#quality-checks","title":"Quality Checks","text":"<p>After bulk operations:</p> <ol> <li> <p>Check lesson count <pre><code>lingq get lessons ja 129129\n</code></pre></p> </li> <li> <p>Verify sorting</p> </li> <li>View course on website</li> <li> <p>Check first and last lessons</p> </li> <li> <p>Test audio sync</p> </li> <li>Open a few lessons</li> <li>Verify timestamps work</li> </ol>"},{"location":"tutorials/managing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/managing/#sort-not-working","title":"Sort Not Working","text":"<p>If lessons don't sort correctly:</p> <ol> <li> <p>Check lesson titles <pre><code>lingq get lessons en 129129\n</code></pre></p> </li> <li> <p>Try different sort key <pre><code>lingq sort en 129129 --sort-key natural\n</code></pre></p> </li> <li> <p>Manual reindex first <pre><code>lingq reindex en 129129\nlingq sort en 129129 --sort-key natural\n</code></pre></p> </li> </ol>"},{"location":"tutorials/managing/#timestamp-issues","title":"Timestamp Issues","text":"<p>If timestamps are inaccurate:</p> <ol> <li>Check audio files - ensure correct duration</li> <li>Verify text content - ensure proper sentence breaks</li> <li>Regenerate - delete and recreate timestamps</li> </ol>"},{"location":"tutorials/managing/#merge-problems","title":"Merge Problems","text":"<p>If merge fails:</p> <ol> <li> <p>Verify source courses exist <pre><code>lingq show my en\n</code></pre></p> </li> <li> <p>Check permissions - ensure you own/can access courses</p> </li> <li>Try smaller batches - merge 2 courses at a time</li> </ol>"},{"location":"tutorials/managing/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about uploading content</li> <li>Explore all commands</li> <li>Read common workflows</li> </ul>"},{"location":"tutorials/uploading/","title":"Uploading Content to LingQ","text":"<p>This tutorial covers different methods for uploading content to your LingQ courses.</p>"},{"location":"tutorials/uploading/#prerequisites","title":"Prerequisites","text":"<ul> <li>LingQ CLI installed and configured</li> <li>API key set up (<code>lingq setup yourApiKey</code>)</li> <li>Text files prepared (UTF-8 encoded)</li> <li>Optional: Audio files in supported formats (MP3, M4A, etc.)</li> </ul>"},{"location":"tutorials/uploading/#method-1-text-only","title":"Method 1: Text Only","text":""},{"location":"tutorials/uploading/#simple-upload","title":"Simple Upload","text":"<p>Upload plain text files without audio:</p> <pre><code>lingq post en 129129 \"path/to/texts/\"\n</code></pre> <p>This will: 1. Read all text files from the directory 2. Create one lesson per text file 3. Use the filename as the lesson title</p>"},{"location":"tutorials/uploading/#example-structure","title":"Example Structure","text":"<pre><code>my-texts/\n\u251c\u2500\u2500 Chapter 1.txt\n\u251c\u2500\u2500 Chapter 2.txt\n\u2514\u2500\u2500 Chapter 3.txt\n</code></pre>"},{"location":"tutorials/uploading/#method-2-text-with-audio-exact-matching","title":"Method 2: Text with Audio (Exact Matching)","text":""},{"location":"tutorials/uploading/#when-to-use","title":"When to Use","text":"<p>Use exact matching when your text and audio files have identical names.</p>"},{"location":"tutorials/uploading/#file-structure","title":"File Structure","text":"<pre><code>my-content/\n\u251c\u2500\u2500 texts/\n\u2502   \u251c\u2500\u2500 Lesson 1.txt\n\u2502   \u251c\u2500\u2500 Lesson 2.txt\n\u2502   \u2514\u2500\u2500 Lesson 3.txt\n\u2514\u2500\u2500 audios/\n    \u251c\u2500\u2500 Lesson 1.mp3\n    \u251c\u2500\u2500 Lesson 2.mp3\n    \u2514\u2500\u2500 Lesson 3.mp3\n</code></pre>"},{"location":"tutorials/uploading/#command","title":"Command","text":"<pre><code>lingq post en 129129 \"my-content/texts\" -a \"my-content/audios\" --pairing-strategy exact\n</code></pre>"},{"location":"tutorials/uploading/#method-3-text-with-audio-fuzzy-matching","title":"Method 3: Text with Audio (Fuzzy Matching)","text":""},{"location":"tutorials/uploading/#when-to-use_1","title":"When to Use","text":"<p>Use fuzzy matching when filenames are similar but not identical.</p>"},{"location":"tutorials/uploading/#file-structure_1","title":"File Structure","text":"<pre><code>my-content/\n\u251c\u2500\u2500 texts/\n\u2502   \u251c\u2500\u2500 01 - First Lesson.txt\n\u2502   \u251c\u2500\u2500 02 - Second Lesson.txt\n\u2502   \u2514\u2500\u2500 03 - Third Lesson.txt\n\u2514\u2500\u2500 audios/\n    \u251c\u2500\u2500 first_lesson.mp3\n    \u251c\u2500\u2500 second_lesson.mp3\n    \u2514\u2500\u2500 third_lesson.mp3\n</code></pre>"},{"location":"tutorials/uploading/#command_1","title":"Command","text":"<pre><code>lingq post en 129129 \"my-content/texts\" -a \"my-content/audios\" --pairing-strategy fuzzy\n</code></pre>"},{"location":"tutorials/uploading/#how-it-works","title":"How It Works","text":"<ul> <li>Uses Levenshtein distance to match similar filenames</li> <li>Ignores case and special characters</li> <li>Matches best candidates automatically</li> </ul>"},{"location":"tutorials/uploading/#method-4-zipzipsort-pairing","title":"Method 4: Zip/Zipsort Pairing","text":""},{"location":"tutorials/uploading/#when-to-use_2","title":"When to Use","text":"<p>Use when text and audio files don't have matching names but should be paired in order.</p>"},{"location":"tutorials/uploading/#file-structure_2","title":"File Structure","text":"<pre><code>book/\n\u251c\u2500\u2500 texts/\n\u2502   \u251c\u2500\u2500 chapter_01.txt\n\u2502   \u251c\u2500\u2500 chapter_02.txt\n\u2502   \u2514\u2500\u2500 chapter_03.txt\n\u2514\u2500\u2500 audios/\n    \u251c\u2500\u2500 audio_track_1.mp3\n    \u251c\u2500\u2500 audio_track_2.mp3\n    \u2514\u2500\u2500 audio_track_3.mp3\n</code></pre>"},{"location":"tutorials/uploading/#commands","title":"Commands","text":"<pre><code># Zip: Alphabetical order\nlingq post en 129129 \"book/texts\" -a \"book/audios\" --pairing-strategy zip\n\n# Zipsort: Natural sorting (better for numbers)\nlingq post en 129129 \"book/texts\" -a \"book/audios\" --pairing-strategy zipsort\n</code></pre>"},{"location":"tutorials/uploading/#difference-zip-vs-zipsort","title":"Difference: Zip vs Zipsort","text":"<p>Zip (alphabetical): <pre><code>file1.txt   \u2192 1, 10, 11, 2, 3\nfile2.txt\n...\n</code></pre></p> <p>Zipsort (natural): <pre><code>file1.txt   \u2192 1, 2, 3, 10, 11\nfile2.txt\n...\n</code></pre></p>"},{"location":"tutorials/uploading/#method-5-creating-a-new-course","title":"Method 5: Creating a New Course","text":""},{"location":"tutorials/uploading/#command_2","title":"Command","text":"<pre><code>lingq post ja -c \"My New Course\" \"texts/\" -a \"audios/\" --pairing-strategy zip\n</code></pre>"},{"location":"tutorials/uploading/#what-happens","title":"What Happens","text":"<ol> <li>Creates a new course with the title \"My New Course\"</li> <li>Uploads all lessons to the new course</li> <li>Returns the new course ID</li> </ol>"},{"location":"tutorials/uploading/#getting-the-course-id","title":"Getting the Course ID","text":"<p>The command output will show: <pre><code>Created collection: My New Course (ID: 129999)\nUploading lessons...\n</code></pre></p> <p>Save this ID for future operations.</p>"},{"location":"tutorials/uploading/#post-upload-tasks","title":"Post-Upload Tasks","text":""},{"location":"tutorials/uploading/#generate-timestamps","title":"Generate Timestamps","text":"<p>After uploading with audio:</p> <pre><code>lingq timestamp en 129129\n</code></pre>"},{"location":"tutorials/uploading/#sort-lessons","title":"Sort Lessons","text":"<p>Organize lessons in order:</p> <pre><code>lingq sort en 129129 --sort-key natural\n</code></pre>"},{"location":"tutorials/uploading/#reindex-titles","title":"Reindex Titles","text":"<p>Add consistent numbering:</p> <pre><code>lingq reindex en 129129\n</code></pre>"},{"location":"tutorials/uploading/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/uploading/#file-naming","title":"File Naming","text":"<p>Good Naming Conventions</p> <ul> <li>Use consistent naming patterns</li> <li>Include leading zeros for numbers: <code>01</code>, <code>02</code>, ... <code>10</code></li> <li>Avoid special characters: <code>/</code>, <code>\\</code>, <code>:</code>, <code>*</code>, <code>?</code>, <code>\"</code>, <code>&lt;</code>, <code>&gt;</code>, <code>|</code></li> <li>Keep names descriptive but concise</li> </ul> <p>Good examples: <pre><code>01_introduction.txt\n02_chapter_one.txt\n03_chapter_two.txt\n</code></pre></p> <p>Avoid: <pre><code>intro.txt\n1.txt\nChapterTwo?.txt\n</code></pre></p>"},{"location":"tutorials/uploading/#text-file-format","title":"Text File Format","text":"<p>Text File Requirements</p> <ul> <li>Use UTF-8 encoding</li> <li>Plain text format (.txt)</li> <li>One file per lesson</li> <li>Reasonable length (LingQ has limits per lesson)</li> </ul>"},{"location":"tutorials/uploading/#audio-file-format","title":"Audio File Format","text":"<p>Supported Audio Formats</p> <ul> <li>MP3 (recommended)</li> <li>M4A</li> <li>WAV</li> <li>OGG</li> </ul> <p>Keep file sizes reasonable for upload speed.</p>"},{"location":"tutorials/uploading/#testing-first","title":"Testing First","text":"<p>Test with Small Batches</p> <p>Before uploading an entire book: 1. Test with 2-3 chapters first 2. Verify pairing works correctly 3. Check text and audio alignment 4. Then proceed with full upload</p>"},{"location":"tutorials/uploading/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/uploading/#pairing-failures","title":"Pairing Failures","text":"<p>If text and audio don't pair correctly:</p> <ol> <li> <p>Check file counts <pre><code>ls texts/ | wc -l\nls audios/ | wc -l\n</code></pre>    Counts should match.</p> </li> <li> <p>Try different strategies</p> </li> <li>Start with <code>exact</code></li> <li>If that fails, try <code>fuzzy</code></li> <li> <p>Last resort: <code>zip</code> or <code>zipsort</code></p> </li> <li> <p>Check filenames <pre><code>ls texts/\nls audios/\n</code></pre>    Look for obvious differences.</p> </li> </ol>"},{"location":"tutorials/uploading/#upload-errors","title":"Upload Errors","text":"<p>If upload fails:</p> <ol> <li> <p>Check API key <pre><code>lingq show my en\n</code></pre></p> </li> <li> <p>Verify course ID</p> </li> <li>Check the ID exists</li> <li> <p>Ensure you have permission to upload</p> </li> <li> <p>Check file encoding</p> </li> <li>Ensure UTF-8 encoding</li> <li>Remove BOM if present</li> </ol>"},{"location":"tutorials/uploading/#rate-limiting","title":"Rate Limiting","text":"<p>For large uploads:</p> <ul> <li>The tool includes retry logic</li> <li>Wait between attempts if you hit rate limits</li> <li>Consider splitting very large uploads</li> </ul>"},{"location":"tutorials/uploading/#advanced-batch-uploading","title":"Advanced: Batch Uploading","text":""},{"location":"tutorials/uploading/#multiple-courses-script","title":"Multiple Courses Script","text":"<pre><code>#!/bin/bash\n\nBOOKS=(\n    \"japanese/book1:129129\"\n    \"japanese/book2:129130\"\n    \"japanese/book3:129131\"\n)\n\nfor book in \"${BOOKS[@]}\"; do\n    path=\"${book%%:*}\"\n    course=\"${book##*:}\"\n\n    echo \"Uploading $path to course $course\"\n    lingq post ja $course \"$path/texts\" -a \"$path/audios\" --pairing-strategy zip\n    lingq timestamp ja $course\n    lingq sort ja $course --sort-key natural\ndone\n</code></pre>"},{"location":"tutorials/uploading/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about managing courses</li> <li>Explore all commands</li> <li>Read common workflows</li> </ul>"},{"location":"user-guide/commands/","title":"Commands Overview","text":"<p>The LingQ CLI provides a comprehensive set of commands for managing your LingQ content. This page provides an overview of all available commands.</p> <p>Getting Help</p> <p>Use <code>--help</code> with any command to see detailed usage information: <pre><code>lingq --help              # Show all commands\nlingq post --help         # Show help for post command\nlingq get courses --help  # Show help for get courses command\n</code></pre></p>"},{"location":"user-guide/commands/#command-structure","title":"Command Structure","text":"<p>Commands are organized into logical groups:</p> <pre><code>lingq [GROUP] [COMMAND] [OPTIONS]\n</code></pre>"},{"location":"user-guide/commands/#setup","title":"Setup","text":""},{"location":"user-guide/commands/#lingq-setup","title":"<code>lingq setup</code>","text":"<p>Creates or updates the configuration file with your LingQ API key.</p> <pre><code>lingq setup yourLingqApiKey\n</code></pre> <p>Arguments: - <code>api_key</code>: Your LingQ API key from https://www.lingq.com/en/accounts/apikey/</p>"},{"location":"user-guide/commands/#get-commands","title":"Get Commands","text":"<p>Download content from LingQ.</p>"},{"location":"user-guide/commands/#lingq-get-courses","title":"<code>lingq get courses</code>","text":"<p>Get every course from a list of languages.</p> <pre><code>lingq get courses en de ja\n</code></pre> <p>Arguments: - <code>language_codes</code>: Space-separated list of language codes (e.g., en, de, ja, el)</p> <p>Options: - <code>--owned</code>: Get only courses you own (default: all courses)</p>"},{"location":"user-guide/commands/#lingq-get-lesson","title":"<code>lingq get lesson</code>","text":"<p>Get a single lesson by its ID.</p> <pre><code>lingq get lesson 12345678\n</code></pre> <p>Arguments: - <code>lesson_id</code>: The ID of the lesson to retrieve</p>"},{"location":"user-guide/commands/#lingq-get-lessons","title":"<code>lingq get lessons</code>","text":"<p>Get all lessons from a course.</p> <pre><code>lingq get lessons en 129129\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code (e.g., en, de, ja) - <code>course_id</code>: The ID of the course (find it with <code>lingq show my &lt;language_code&gt;</code> or from the course URL)</p> <p>How to Find Course IDs</p> <ul> <li>Run <code>lingq show my en</code> to see all your English courses with their IDs</li> <li>Or get the ID from the URL: <code>https://www.lingq.com/.../course/129129</code> \u2192 129129</li> </ul>"},{"location":"user-guide/commands/#lingq-get-words","title":"<code>lingq get words</code>","text":"<p>Export your vocabulary (LingQs) for a language.</p> <pre><code>lingq get words ja\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code to export words from</p> <p>Options: - <code>--status</code>: Filter by status (0=new, 1=recognized, 2=familiar, 3=learned, 4=known)</p>"},{"location":"user-guide/commands/#lingq-get-images","title":"<code>lingq get images</code>","text":"<p>Download images from lessons.</p> <pre><code>lingq get images en 129129\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code - <code>course_id</code>: Course ID</p>"},{"location":"user-guide/commands/#post-commands","title":"Post Commands","text":"<p>Upload content to LingQ.</p>"},{"location":"user-guide/commands/#lingq-post","title":"<code>lingq post</code>","text":"<p>Upload lessons with text and optional audio files.</p> <pre><code>lingq post en 129129 \"texts/\" -a \"audios/\" --pairing-strategy zip\n</code></pre> <p>Arguments: - <code>language_code</code>: Target language code - <code>course_id</code>: Target course ID - <code>texts_path</code>: Path to directory containing text files</p> <p>Options: - <code>-a, --audios-path</code>: Path to directory containing audio files - <code>-c, --collection-title</code>: Create new course with this title - <code>--pairing-strategy</code>: How to match text and audio files:     - <code>exact</code>: Exact filename match (default)     - <code>fuzzy</code>: Fuzzy matching using Levenshtein distance     - <code>zip</code>: Match files by alphabetical order     - <code>zipsort</code>: Match using natural sorting</p> <p>Example with new course: <pre><code>lingq post ja -c \"My Japanese Book\" \"chapters/\" -a \"audio/\" --pairing-strategy zip\n</code></pre></p>"},{"location":"user-guide/commands/#lingq-postyt","title":"<code>lingq postyt</code>","text":"<p>Upload a YouTube playlist to a course.</p> <pre><code>lingq postyt en 129129 \"https://www.youtube.com/@channel\"\n</code></pre> <p>Arguments: - <code>language_code</code>: Target language code - <code>course_id</code>: Target course ID (or use <code>-c</code> for new course) - <code>url</code>: YouTube playlist or channel URL</p> <p>Options: - <code>-c, --collection-title</code>: Create new course with this title - <code>--caption-language</code>: Language code for captions (defaults to target language)</p> <p>Features: - Automatically downloads captions if available - Extracts audio from videos - Creates lessons with synchronized text and audio</p>"},{"location":"user-guide/commands/#timestamp","title":"Timestamp","text":"<p>Generate timestamps for lessons with audio.</p>"},{"location":"user-guide/commands/#lingq-timestamp","title":"<code>lingq timestamp</code>","text":"<p>Automatically generate timestamps for a course.</p> <pre><code>lingq timestamp de 129129\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code - <code>course_id</code>: Course ID</p> <p>Options: - <code>--lesson-ids</code>: Process specific lessons only (space-separated IDs)</p> <p>How it works: - Uses audio duration and text length to generate proportional timestamps - Adds timestamps to lessons that don't have them - Skips lessons that already have timestamps</p>"},{"location":"user-guide/commands/#patch-commands","title":"Patch Commands","text":"<p>Update existing content.</p>"},{"location":"user-guide/commands/#lingq-patch-audios","title":"<code>lingq patch audios</code>","text":"<p>Replace or add audio to existing lessons.</p> <pre><code>lingq patch audios en 129129 \"new_audio/\"\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code - <code>course_id</code>: Course ID - <code>audios_path</code>: Path to directory containing new audio files</p> <p>Options: - <code>--pairing-strategy</code>: Matching strategy (exact, fuzzy, zip, zipsort)</p>"},{"location":"user-guide/commands/#sort-commands","title":"Sort Commands","text":""},{"location":"user-guide/commands/#lingq-sort","title":"<code>lingq sort</code>","text":"<p>Sort lessons in a course using various sorting strategies.</p> <pre><code>lingq sort en 129129 --sort-key natural\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code - <code>course_id</code>: Course ID</p> <p>Options: - <code>--sort-key</code>: Sorting strategy:     - <code>natural</code>: Natural sorting (handles numbers correctly)     - <code>greek</code>: Greek alphabet order     - <code>roman</code>: Roman numeral order     - <code>versioned</code>: Version number sorting (e.g., 1.1, 1.2, 2.1)</p>"},{"location":"user-guide/commands/#resplit","title":"Resplit","text":""},{"location":"user-guide/commands/#lingq-resplit","title":"<code>lingq resplit</code>","text":"<p>Resplit Japanese lessons using updated tokenization.</p> <pre><code>lingq resplit ja 129129\n</code></pre> <p>Arguments: - <code>language_code</code>: Must be <code>ja</code> (Japanese only) - <code>course_id</code>: Course ID</p> <p>Use case: - Updates word segmentation in Japanese lessons - Useful when LingQ updates their tokenization algorithm</p>"},{"location":"user-guide/commands/#markdown","title":"Markdown","text":""},{"location":"user-guide/commands/#lingq-markdown","title":"<code>lingq markdown</code>","text":"<p>Generate markdown documentation of your courses.</p> <pre><code>lingq markdown en ja --no-views\n</code></pre> <p>Arguments: - <code>language_codes</code>: Space-separated list of language codes</p> <p>Options: - <code>--no-views</code>: Exclude view counts from generated markdown - <code>--mine</code>: Only include courses you own - <code>--shared</code>: Only include shared courses</p> <p>Output: - Creates markdown files in <code>etc/markdowns/</code> directory - Includes course structure, lesson titles, and statistics</p>"},{"location":"user-guide/commands/#yomitan","title":"Yomitan","text":""},{"location":"user-guide/commands/#lingq-yomitan","title":"<code>lingq yomitan</code>","text":"<p>Create a Yomitan dictionary from exported LingQs.</p> <pre><code>lingq get words ja  # First export words\nlingq yomitan ja\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code</p> <p>Requirements: - Must first run <code>lingq get words</code> to create the dump file - Currently supports Japanese best</p> <p>Use case: - Import your LingQ vocabulary into the Yomitan browser extension - Study with flashcards in your browser</p>"},{"location":"user-guide/commands/#show-commands","title":"Show Commands","text":"<p>Display information about your library.</p>"},{"location":"user-guide/commands/#lingq-show-my","title":"<code>lingq show my</code>","text":"<p>Show all your collections in a language.</p> <pre><code>lingq show my en\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code</p> <p>Output: - Lists all your courses with IDs and titles - Useful for finding course IDs</p>"},{"location":"user-guide/commands/#overview","title":"Overview","text":""},{"location":"user-guide/commands/#lingq-overview","title":"<code>lingq overview</code>","text":"<p>Generate a CSV overview of your entire library.</p> <pre><code>lingq overview\n</code></pre> <p>Output: - Creates a CSV file with all courses across all languages - Includes statistics like lesson count, word count, etc.</p>"},{"location":"user-guide/commands/#statistics","title":"Statistics","text":""},{"location":"user-guide/commands/#lingq-stats","title":"<code>lingq stats</code>","text":"<p>Show reading statistics for a language.</p> <pre><code>lingq stats ja\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code</p> <p>Output: - Known words count - Reading hours - Lessons completed - And more statistics</p>"},{"location":"user-guide/commands/#merge","title":"Merge","text":""},{"location":"user-guide/commands/#lingq-merge","title":"<code>lingq merge</code>","text":"<p>Merge multiple courses into one.</p> <pre><code>lingq merge en 129129 129130 129131 -t \"Combined Course\"\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code - <code>course_ids</code>: Space-separated course IDs to merge</p> <p>Options: - <code>-t, --title</code>: Title for the merged course</p>"},{"location":"user-guide/commands/#reindex","title":"Reindex","text":""},{"location":"user-guide/commands/#lingq-reindex","title":"<code>lingq reindex</code>","text":"<p>Reindex lesson titles with automatic numbering.</p> <pre><code>lingq reindex en 129129\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code - <code>course_id</code>: Course ID</p> <p>Use case: - Add consistent numbering to lesson titles - Fix gaps in numbering after deleting lessons</p>"},{"location":"user-guide/commands/#replace","title":"Replace","text":""},{"location":"user-guide/commands/#lingq-replace","title":"<code>lingq replace</code>","text":"<p>Replace text in lessons using regex patterns.</p> <pre><code>lingq replace en 129129 \"old_pattern\" \"new_text\"\n</code></pre> <p>Arguments: - <code>language_code</code>: Language code - <code>course_id</code>: Course ID - <code>pattern</code>: Regex pattern to find - <code>replacement</code>: Text to replace with</p> <p>Use case: - Fix recurring typos across multiple lessons - Update formatting consistently</p>"},{"location":"user-guide/commands/#next-steps","title":"Next Steps","text":"<ul> <li>Learn common workflows</li> <li>Explore API reference</li> <li>Read tutorials</li> </ul>"},{"location":"user-guide/workflows/","title":"Common Workflows","text":"<p>This guide walks you through common workflows and use cases for the LingQ CLI.</p>"},{"location":"user-guide/workflows/#uploading-a-book-with-audio","title":"Uploading a Book with Audio","text":""},{"location":"user-guide/workflows/#scenario","title":"Scenario","text":"<p>You have a book split into chapters as text files and corresponding audio files.</p>"},{"location":"user-guide/workflows/#steps","title":"Steps","text":"<ol> <li>Organize your files</li> </ol> <p>Create two directories:    <pre><code>my-book/\n\u251c\u2500\u2500 texts/\n\u2502   \u251c\u2500\u2500 01 - Chapter One.txt\n\u2502   \u251c\u2500\u2500 02 - Chapter Two.txt\n\u2502   \u2514\u2500\u2500 03 - Chapter Three.txt\n\u2514\u2500\u2500 audios/\n    \u251c\u2500\u2500 01 - Chapter One.mp3\n    \u251c\u2500\u2500 02 - Chapter Two.mp3\n    \u2514\u2500\u2500 03 - Chapter Three.mp3\n</code></pre></p> <ol> <li>Create a new course and upload</li> </ol> <pre><code>lingq post ja -c \"My Japanese Book\" \"my-book/texts\" -a \"my-book/audios\" --pairing-strategy exact\n</code></pre> <p>Or upload to an existing course:    <pre><code>lingq post ja 129129 \"my-book/texts\" -a \"my-book/audios\" --pairing-strategy exact\n</code></pre></p> <ol> <li>Generate timestamps</li> </ol> <pre><code>lingq timestamp ja 129129\n</code></pre>"},{"location":"user-guide/workflows/#pairing-strategies","title":"Pairing Strategies","text":"<p>Choose the right strategy for your files:</p> <ul> <li>exact: When text and audio have identical filenames (default)</li> <li>fuzzy: When filenames are similar but not identical</li> <li>zip: When files should match in alphabetical order</li> <li>zipsort: When files should match using natural sorting (handles numbers better)</li> </ul> <p>Example with fuzzy matching: <pre><code>lingq post en 129129 \"texts/\" -a \"audios/\" --pairing-strategy fuzzy\n</code></pre></p>"},{"location":"user-guide/workflows/#importing-youtube-content","title":"Importing YouTube Content","text":""},{"location":"user-guide/workflows/#scenario_1","title":"Scenario","text":"<p>You want to import videos from a YouTube channel into your course.</p>"},{"location":"user-guide/workflows/#steps_1","title":"Steps","text":"<ol> <li>Get the channel or playlist URL</li> </ol> <p>Examples:    - Channel: <code>https://www.youtube.com/@channelname</code>    - Playlist: <code>https://www.youtube.com/playlist?list=PLxxxxxx</code></p> <ol> <li>Upload to a new course</li> </ol> <pre><code>lingq postyt de -c \"German Videos\" \"https://www.youtube.com/@germanchannel\"\n</code></pre> <ol> <li>Specify caption language (if different)</li> </ol> <pre><code>lingq postyt en 129129 \"https://www.youtube.com/@channel\" --caption-language en-US\n</code></pre>"},{"location":"user-guide/workflows/#what-happens","title":"What Happens","text":"<ul> <li>Downloads video captions (if available)</li> <li>Extracts audio from videos</li> <li>Creates lessons with synchronized text and audio</li> <li>Names lessons based on video titles</li> </ul> <p>Caption Availability</p> <p>The tool will automatically download captions if they're available. If not, you'll need to provide transcripts separately.</p>"},{"location":"user-guide/workflows/#exporting-vocabulary","title":"Exporting Vocabulary","text":""},{"location":"user-guide/workflows/#scenario_2","title":"Scenario","text":"<p>You want to export your LingQs (vocabulary) for backup or external use.</p>"},{"location":"user-guide/workflows/#steps_2","title":"Steps","text":"<ol> <li>Export all words</li> </ol> <pre><code>lingq get words ja\n</code></pre> <ol> <li>Export by status</li> </ol> <pre><code># Export only words you're learning (status 1-2)\nlingq get words ja --status 1\nlingq get words ja --status 2\n</code></pre> <ol> <li>Create a Yomitan dictionary</li> </ol> <pre><code>lingq get words ja\nlingq yomitan ja\n</code></pre>"},{"location":"user-guide/workflows/#status-codes","title":"Status Codes","text":"<ul> <li><code>0</code>: New (yellow)</li> <li><code>1</code>: Recognized (light blue)</li> <li><code>2</code>: Familiar (dark blue)</li> <li><code>3</code>: Learned (light gray)</li> <li><code>4</code>: Known (white)</li> </ul>"},{"location":"user-guide/workflows/#organizing-and-sorting-lessons","title":"Organizing and Sorting Lessons","text":""},{"location":"user-guide/workflows/#scenario_3","title":"Scenario","text":"<p>Your lessons are out of order or need consistent numbering.</p>"},{"location":"user-guide/workflows/#sorting-lessons","title":"Sorting Lessons","text":"<pre><code># Natural sort (handles numbers correctly)\nlingq sort en 129129 --sort-key natural\n\n# Greek alphabet order\nlingq sort el 129129 --sort-key greek\n\n# Roman numerals\nlingq sort la 129129 --sort-key roman\n\n# Version numbers (1.1, 1.2, 2.1, etc.)\nlingq sort en 129129 --sort-key versioned\n</code></pre>"},{"location":"user-guide/workflows/#reindexing-lessons","title":"Reindexing Lessons","text":"<p>Add consistent numbering:</p> <pre><code>lingq reindex en 129129\n</code></pre> <p>This will rename lessons like: <pre><code>Before:            After:\nChapter One     \u2192 1. Chapter One\nIntroduction    \u2192 2. Introduction\nFinal Chapter   \u2192 3. Final Chapter\n</code></pre></p>"},{"location":"user-guide/workflows/#batch-processing-multiple-courses","title":"Batch Processing Multiple Courses","text":""},{"location":"user-guide/workflows/#scenario_4","title":"Scenario","text":"<p>You want to generate timestamps for all your German courses.</p>"},{"location":"user-guide/workflows/#steps_3","title":"Steps","text":"<ol> <li>Get all your courses</li> </ol> <pre><code>lingq get courses de\n</code></pre> <p>Note the course IDs.</p> <ol> <li>Process each course</li> </ol> <pre><code>lingq timestamp de 129129\nlingq timestamp de 129130\nlingq timestamp de 129131\n</code></pre>"},{"location":"user-guide/workflows/#script-example","title":"Script Example","text":"<p>For multiple operations, create a bash script:</p> <pre><code>#!/bin/bash\n\nCOURSES=(129129 129130 129131 129132)\n\nfor course in \"${COURSES[@]}\"; do\n    echo \"Processing course $course\"\n    lingq timestamp de $course\n    lingq sort de $course --sort-key natural\ndone\n</code></pre>"},{"location":"user-guide/workflows/#updating-audio-files","title":"Updating Audio Files","text":""},{"location":"user-guide/workflows/#scenario_5","title":"Scenario","text":"<p>You have better quality audio files and want to replace existing ones.</p>"},{"location":"user-guide/workflows/#steps_4","title":"Steps","text":"<ol> <li>Organize new audio files</li> </ol> <pre><code>new-audio/\n\u251c\u2500\u2500 Lesson 1.mp3\n\u251c\u2500\u2500 Lesson 2.mp3\n\u2514\u2500\u2500 Lesson 3.mp3\n</code></pre> <ol> <li>Patch the course</li> </ol> <pre><code>lingq patch audios en 129129 \"new-audio/\" --pairing-strategy fuzzy\n</code></pre>"},{"location":"user-guide/workflows/#creating-documentation","title":"Creating Documentation","text":""},{"location":"user-guide/workflows/#scenario_6","title":"Scenario","text":"<p>You want to create markdown documentation of your courses for backup or sharing.</p>"},{"location":"user-guide/workflows/#steps_5","title":"Steps","text":"<ol> <li>Generate markdown for all languages</li> </ol> <pre><code>lingq markdown en de ja el\n</code></pre> <ol> <li>Generate for only your courses</li> </ol> <pre><code>lingq markdown en --mine\n</code></pre> <ol> <li>Exclude view counts</li> </ol> <pre><code>lingq markdown en --no-views\n</code></pre>"},{"location":"user-guide/workflows/#output-location","title":"Output Location","text":"<p>Files are saved to <code>etc/markdowns/</code> organized by options: - <code>markdown_all/</code> - All courses - <code>markdown_mine/</code> - Only your courses - <code>markdown_shared/</code> - Only shared courses - <code>*_no_views/</code> - Versions without view counts</p>"},{"location":"user-guide/workflows/#fixing-text-issues","title":"Fixing Text Issues","text":""},{"location":"user-guide/workflows/#scenario_7","title":"Scenario","text":"<p>You need to fix recurring formatting issues across multiple lessons.</p>"},{"location":"user-guide/workflows/#using-replace","title":"Using Replace","text":"<pre><code># Fix double spaces\nlingq replace en 129129 \"  \" \" \"\n\n# Remove unwanted characters\nlingq replace ja 129129 \"\u3010.*?\u3011\" \"\"\n\n# Update formatting\nlingq replace de 129129 \"(\\d+)\\.\" \"$1)\"\n</code></pre> <p>Regex Patterns</p> <p>The pattern parameter uses regex. Test patterns carefully before applying to important courses.</p>"},{"location":"user-guide/workflows/#resplitting-japanese-lessons","title":"Resplitting Japanese Lessons","text":""},{"location":"user-guide/workflows/#scenario_8","title":"Scenario","text":"<p>LingQ updated their Japanese tokenization and you want to update your lessons.</p>"},{"location":"user-guide/workflows/#steps_6","title":"Steps","text":"<pre><code>lingq resplit ja 129129\n</code></pre> <p>This will: - Re-tokenize all text in the course - Update word boundaries - Preserve your LingQs</p> <p>Japanese Only</p> <p>This command only works for Japanese (ja) language code.</p>"},{"location":"user-guide/workflows/#finding-course-ids","title":"Finding Course IDs","text":""},{"location":"user-guide/workflows/#scenario_9","title":"Scenario","text":"<p>You need to find the ID of a course to use in commands.</p> <p>Quick Method</p> <p>The easiest way is: <code>lingq show my &lt;language_code&gt;</code> - this shows all your courses with their IDs.</p>"},{"location":"user-guide/workflows/#methods","title":"Methods","text":"<ol> <li>Show all your courses (recommended)</li> </ol> <pre><code>lingq show my en\n</code></pre> <p>Output example: <pre><code>Course ID: 129129 - My English Course\nCourse ID: 129130 - Another Course\n</code></pre></p> <ol> <li>Get all courses in a language</li> </ol> <pre><code>lingq get courses en\n</code></pre> <p>This shows all courses (not just yours) and includes more details.</p> <ol> <li>From the LingQ website URL</li> </ol> <p>When viewing a course on the LingQ website, the course ID is in the URL:    <pre><code>https://www.lingq.com/en/learn/en/web/course/129129\n                                           ^^^^^^\n                                         Course ID\n</code></pre></p>"},{"location":"user-guide/workflows/#working-with-specific-lessons","title":"Working with Specific Lessons","text":""},{"location":"user-guide/workflows/#scenario_10","title":"Scenario","text":"<p>You want to timestamp only specific lessons in a course.</p>"},{"location":"user-guide/workflows/#steps_7","title":"Steps","text":"<pre><code># Timestamp specific lessons by ID\nlingq timestamp en 129129 --lesson-ids 12345678 12345679 12345680\n</code></pre>"},{"location":"user-guide/workflows/#next-steps","title":"Next Steps","text":"<ul> <li>Explore all commands</li> <li>Read API reference</li> <li>Check out tutorials</li> </ul>"}]}